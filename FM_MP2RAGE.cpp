//    -----------------------------------------------------------------------------
//      Copyright (C) Siemens AG 1998  All Rights Reserved.
//    -----------------------------------------------------------------------------
//
//     Project: NUMARIS/4
//        File: \n4_servers1\pkg\MrServers\MrImaging\seq\FM_MP2RAGE\FM_MP2RAGE.cpp
//     Version: \main\4c11a_er\4d13c\2
//      Author: Clinical
//        Date: 2013-01-08 13:46:10 +01:00
//
//        Lang: C++
//
//     Remarks: This is the demo sequence FM_MP2RAGE.
//              DO NOT base any diagnosis on images generated by this sequence.
//
//
//  EGA Requirement Key: As shown on the following lines:
//
//   Abbrev.   Translation                                         Relevant for
//   -------   -----------                                         ------------
//   EGA-All   All of the following keys:                          All EGA requirements
//   EGA-Any   All or any of the following keys:                   All EGA requirements
//   EGA-01    {:IMPLEMENT:000_EGA_BildOri_SW_SequenzROVz::}       GR/GP   polarity
//   EGA-02    {:IMPLEMENT:000_EGA_BildPos_SW_SequenzSSelVz::}     GS      polarity
//   EGA-03    {:IMPLEMENT:000_EGA_BildMass_SW_SequenzROPC::}      GR/GP   amplitude
//   EGA-04    {:IMPLEMENT:000_EGA_BildPos_SW_SequenzSSel::}       GS      amplitude
//   EGA-05    {:IMPLEMENT:000_EGA_BildPos_SW_NCOFrequenzSSel::}   SRF     frequency
//   EGA-06    {:IMPLEMENT:000_EGA_BildPos_SW_NCOFrequenzRO::}     Readout frequency
//   EGA-07    {:IMPLEMENT:000_EGA_BildOri_SW_OrientierungTest::}  Image orientation
//
//
//
//
//
/// \file   FlASH.cpp
/// \brief  File containing source code for the sequences
///         - FM_MP2RAGE
///
/// This file contains the implementation of the class FM_MP2RAGE.
/// The sequence FM_MP2RAGE and Flash1 use it to generate very nice images.
///
//  **************************************************************************



// ------------------------------------------------------------------------------
// Application includes
// ------------------------------------------------------------------------------
#include "MrServers/MrImaging/seq/FM_MP2RAGE/FM_MP2RAGE.h"
#include "MrServers/MrImaging/seq/FM_MP2RAGE/FM_MP2RAGE_UI.h"
#include <stdio.h>
#include <vector>
#include <time.h>
// ------------------------------------------------------------------------------
// General includes
// ------------------------------------------------------------------------------
#include "MrServers/MrImaging/libSeqUtil/libSeqUtil.h"
#include "MrServers/MrMeasSrv/MeasNuclei/IF/MeasKnownNuclei.h"
#include "MrServers/MrProtSrv/MrProt/MeasParameter/MrSysSpec.h"
#include "MrServers/MrProtSrv/MrProt/MeasParameter/MrRXSpec.h"
#include "MrServers/MrMeasSrv/PMU/pmuSequence.h"//pierre
#include "MrServers/MrImaging/seq/common/parameter_map3.h"


// Error handling routines.
// Many functions return a NLS_STATUS (NLS = Native Language Support).
// This code is used to produce error messages in different languages.
// With this method it is possible to display sensible error messages in the user interface,
//  if the error code is passed correctly to the caller function
// In most cases, one checks whether the highest two bits of the return status are set.
// In the sequence, the use of SEQU__NORMAL as return value is used to signal ok.
//
#define OnErrorReturn(S) if(!MrSucceeded(S)) return(S)

#define OnErrorPrintAndReturn(S,P) if (!MrSucceeded(S)) \
	{ MRTRACE("Error from %s \n",P); return(S);}


//  --------------------------------------------------------------------------
//
//  Name        :  SEQIF_DEFINE
//
//  Description :
///  \brief        Create instance of the sequence
//
//  Return      :  SeqIF *
//
//  --------------------------------------------------------------------------

#ifdef BUILD_PLATFORM_LINUX// pierre
static CPmuSequence m_PMU;
#endif


#ifndef SEQ_NAMESPACE
#error SEQ_NAMESPACE not defined
#endif


#ifdef SEQUENCE_CLASS_FM_MP2RAGE
SEQIF_DEFINE (SEQ_NAMESPACE::FM_MP2RAGE)
#endif


using namespace SEQ_NAMESPACE;
using namespace std;

//. ----------------------------------------------------------
//. Instantiate gradietns tables this is durty but who gives a fuck
//. ----------------------------------------------------------
std::vector<float> Gradx( 200000);
std::vector<float> Grady( 200000);
std::vector<float> Gradz( 200000);

std::vector<float> GradxT( 400000);
std::vector<float> GradyT( 400000);
std::vector<float> GradzT( 400000);
//Dephasing gradients 
std::vector<float> GradxDeph( 200000);
std::vector<float> GradyDeph( 200000);
std::vector<float> GradzDeph( 200000);

std::vector<float> GradxDephT( 400000);
std::vector<float> GradyDephT( 400000);
std::vector<float> GradzDephT( 400000);
// in case of reorder -> dummy copies
std::vector<float> GradxTemp( 200000);
std::vector<float> GradyTemp( 200000);
std::vector<float> GradzTemp(200000);
// in case of reoder -> Dephasign gradients
std::vector<float> GradxDephTemp( 200000);
std::vector<float> GradyDephTemp( 200000);
std::vector<float> GradzDephTemp(200000);

static long dummy=1;

//. ----------------------------------------------------------
//. Instantiate FM_MP2RAGE ui parameter and Gradient tables (ParameterMap)
//. ----------------------------------------------------------
 // MP2RAGE variables
 long u_lTI1;
 long u_lTI2;
 long u_lTotalTR;

 long u_lETL					;  //size of the Echo Train Length

 long u_Projections(10); // Define the number of projections required
 long l_offset;
 selection u_AcqMode;
 selection u_Mode;
 long l_spoilAmp;
 bool u_dummyScan;
 bool u_Selfgating;
 long l_ECGPhaseNumb=0;
 long l_RESPPhaseNumb=0;

// STEADY STATE
bool bTrigTest=true;
long lPhysCount=0;
long lPhysiolTime;
long lDumcount=0;
int ProjectionToMeasure= 0;
int MaxProjectionInPhase=0;
bool u_bDoCalibration;
double l_version =  2.2;
double l_currentVersion;
bool u_bDump;
// An elegant way to switch debug messages on and off without recompiling the sequence can be
//   done by entering the debug mask in the windows registry, e.g. into
//    \\HKEY_LOCAL_MACHINE\\SOFTWARE\\Siemens\\Numaris4\\Config\\Modality\\Sequence\\DEBUG_USER_SEQUENCE
//    (this registry entry has to be defined by yourself.)
// The numerical value can be set by the programs configui (on the Scanner) or regedit (stand-alone PC),
//  so one can select the desired piece of debugging information by setting the correspondig bits

//   Then the following Macro can be used:
#define DEBUG_BY_REGISTRY(A, B){if (lDebugMask & A){std::cout  << __FILE__ << ": " << B << std::endl;}}
//   This macro allows the copntrolled output of bebug information, depending of the settings in
//    the DEBUG_USER_SEQUENCE-registry entry. Example:
//-  DEBUG_BY_REGISTRY(16," This is my debug text with TR: " << rMrProt.tr()[0] )
//    will dump "FM_MP2RAGE.cpp:  This is my debug text with TR: 1000" to the standard output, if
//    the bit 5 in the registry-key is set.

// NOTE: Setting the corresonding registry entry will cause ALL of your sequences using this key for debugging
//      to generate verbose output, which may decrease performance. So be aware of this global effect.

#define TRUE_IF_DETAILED_DEBUG ( lDebugMask > 63 )
long lDebugMask = getMaskFromRegistry ("DEBUG_USER_SEQUENCE") ; // read the debug value in a global
//  variable, since function call is slow


FM_MP2RAGE::FM_MP2RAGE()
: m_lRepetitionsToMeasure                       (0)
, m_lLinesToMeasure                             (1)
, m_lPhasesToMeasure                            (1)
, m_lSlicesToMeasure                            (1)
, m_lContrastsToMeasure                         (1)
, m_lPartitionsToMeasure                        (1)
, m_lScanTimeAllSats                            (0)
, m_lDurationMainEventBlock                     (0)
, m_lKernelRequestsPerMeasurement               (0)
, m_lKernelCallsPerRelevantSignal               (0)
, m_lInterDuration                              (0)
, m_lTrigHaltDuration1                          (0)
, m_lTrigHaltDuration2                          (0)
, m_dRFSpoilIncrement                           (0)
, m_dRFSpoilPhase                               (0)
, m_lMySliSelRampTime                           (0)
, m_dMinRiseTime                                (100000)
, m_dGradMaxAmpl                                (0)
,duration										(0)
,DephGradAmpl									(0)
,readMoment										(0)


, m_FirstSignal                                 (SEQ::SIGNAL_NONE)
, m_FirstMethod                                 (SEQ::METHOD_NONE)
, m_SecondSignal                                (SEQ::SIGNAL_NONE)
, m_SecondMethod                                (SEQ::METHOD_NONE)

, m_sSRF                                        ("FM_MP2RAGE_ex")
, m_sSRFzSet                                    ("m_sSRFzSet")
, m_sSRFzNeg                                    ("m_sSRFzNeg")
, m_sGradRead                                   ("m_sGradRead")        
, m_sGradSlice                                  ("m_sGradSlice")
, m_sGradPhase                                  ("m_sGradPhase") 
, m_sGSpoil                                     ("m_sGSpoil")
, m_sGradReadDeph                               ("sGradReadDeph")         
, m_sGradSliceDeph                              ("sGradSliceDeph")
, m_sGradPhaseDeph                              ("sGradPhaseDeph") 
, m_sGradReadDephFM                             ("sGradReadDephFM")
, m_sGradPhaseDephFM                            ("sGradPhaseDephFM")
, m_sGradSliceDephFM                            ("sGradSliceDephFM")
, m_sGradReadRephFM								("sGradReadRephFM")
, m_sGradPhaseRephFM							("sGradPhaseRephFM")
, m_sGradSliceRephFM							("sGradSliceRephFM")

//FMUTE
, m_sGradReadReph								("m_sGradReadReph")
, m_sGradPhaseReph								("m_sGradPhaseReph")
, m_sGradSliceReph								("m_sGradSliceReph")
, m_sGSpoilFM									("m_sGSpoilFM")
, m_sADCsgSet                                   ("m_sADCsgSet")
, m_sADCsgNeg                                   ("m_sADCsgNeg")

, m_sADCzSet                                    ("m_sADCzSet")
, m_sADCzNeg                                    ("m_sADCzNeg")

, m_IRnsSBB()  // inversion pulse
, m_IRns(&m_IRnsSBB)// inversion pulse

, m_TokTokSBB                                   (&m_mySBBList)
, m_CSatFatSBB                                  (&m_mySBBList)
, m_CSatWatSBB                                  (&m_mySBBList)
, m_MSatSBB                                     (&m_mySBBList)
, m_TSatSBB                                     (&m_mySBBList)
, m_SpoilSBB                                    (&m_mySBBList)
, m_pUI                                         (NULL)
, m_mySBBlist()
, m_SBBCALIB   (&m_mySBBlist)
 {
	// no further instructions...
}


FM_MP2RAGE::~FM_MP2RAGE()
{
	// Delete UI instance if an UI instance exists
	if (NULL != m_pUI) {
		delete m_pUI;
		m_pUI = NULL;
	}

}





//   --------------------------------------------------------------------------
//
//   Name        :  FM_MP2RAGE::initialize
//
//   Description :
///  \brief        Initialization of the sequence
///
///                On the host, the object m_pUI will actually contain sensible
///                  data after FM_MP2RAGE::initialize. On the measurement system, it
///                  is basically an empty object behind it.
///
//   Return      :  NLS status
//
//   --------------------------------------------------------------------------
NLSStatus FM_MP2RAGE::initialize (SeqLim &rSeqLim)
{

    //. --------------------------------------------------------
	//. Declaration of local variables
	//. --------------------------------------------------------
	NLS_STATUS  lStatus = SEQU__NORMAL;
	// name the current Module
	static const char *ptModule = {"fSEQInit"};
	// some helper variables
	double      dMin, dMax, dInc, dDef;
	long        lMin, lMax, lInc, lDef;

	// if the mask is set to INIT and CALL, print some text
	mPrintTrace0 (DEBUG_INIT, DEBUG_CALL,
	"() >>>> Welcome to the clean FM_MP2RAGE sequence  (Build: "__DATE__"   "__TIME__")") ;
	// If DEBUG_INIT is set, dump information that fSEQInit has been called
	if ( rSeqLim.getSeqDebugMode().getDebugMask()& DEBUG_INIT ) mPrintDebugMask ();

	dMin = dMax = dInc = dDef = 0.0;
	lMin = lMax = lInc = lDef = 0;


	//. --------------------------------------------------------
	//. Give general information about the sequence
	//. --------------------------------------------------------
	rSeqLim.setMyOrigFilename ( __FILE__ );
	rSeqLim.setSequenceOwner    ( "USER" );
	rSeqLim.setSequenceHintText( (char *) "\n\
	Application: UTE template sequence     \n\
	Build: "__DATE__"   "__TIME__"\n")  ;


	//. -----------------------------------------------------------------------------
	//. Define the system requirements like frequency and gradient power
	//. -----------------------------------------------------------------------------
	rSeqLim.setAllowedFrequency     (8000000, 500000000); // Hz
	rSeqLim.setRequiredGradAmpl     (10.0);               // mT/m
	rSeqLim.setRequiredGradSlewRate (10.0);               // (mT/m)/ms
	rSeqLim.setGradients(SEQ::GRAD_FAST);
	rSeqLim.setSupportedNuclei(NUCLEI_ALL.get().c_str());    // Enable X-nuclei imaging


	//. -----------------------------
	//. Specify base matrix size of the image
	//. -----------------------------
	rSeqLim.setBaseResolution            ( 32, 512, SEQ::INC_NORMAL, 256);
	rSeqLim.setPELines                   (32, 1024, 1, rSeqLim.getBaseResolution().getDef());


	//. --------------------------------------------------------------------------
	//. Set the hard limits for Field of View
	//. --------------------------------------------------------------------------
	dMax = SysProperties::getFoVMax() ;   // maximum FoV depends on gradient linearity
	dDef = 350.0;                     // default FOV is 350 mm
	dInc =   1.0;                     // allowed stepsize is 1 mm
	dMin =   20;                      // minimum FoV is limited by the gradient performance.
	dMin = fSDSdRoundUpMinimum(dMin, dMax, dInc);
	if (dDef < dMin) dDef = dMin;
	if (dDef > dMax) dDef = dMax;

	rSeqLim.setReadoutFOV                ( dMin, dMax, dInc, dDef );
	rSeqLim.setPhaseFOV                  ( dMin, dMax, dInc, dDef );

	rSeqLim.setReadoutFOV                ( dMin, dMax, dInc, dDef );
	rSeqLim.setSquareFOVOnly(1);
	rSeqLim.setPhaseFOV                  ( dMin, dMax, dInc, dDef );

	//. --------------------------------------------------------------------------
	//. Set TE / TR hard limits
	//. --------------------------------------------------------------------------
	rSeqLim.setTR                        (               0,           100, 5000000,     100,    4000);
	
	
	rSeqLim.setTE                        (          0 ,              70,    50000,      10,        70);		
	   

	//. ------------------------------
	//. Set TI limits
	//. -------------------------------
	rSeqLim.setInversion (SEQ::INVERSION_OFF);

	//. --------------------------------------------------------------------------------------
	//. Define limits for slices, excitation order etc.
	//. --------------------------------------------------------------------------------------
	rSeqLim.setConcatenations       (           1,           1,           1,           1)  ;
	rSeqLim.setSlices               (           1,           3,           1,           1)  ;// set slice # at 1 Pierre
	rSeqLim.setSliceDistanceFactor  (      0,       0,       0,       0)  ;
	rSeqLim.setSliceSeriesMode ( SEQ::ASCENDING, SEQ::INTERLEAVED, SEQ::DESCENDING);
	rSeqLim.enableMSMA ();         // we allow MSMA

	rSeqLim.enableSliceShift ();   // we allow offcenter slice position
	rSeqLim.enableOffcenter (); 
	rSeqLim.setAllowedSliceOrientation (SEQ::ORTHOGONAL); // alt: ORTHOGONAL, SINGLE_OBLIQUE ,DOUBLE_OBLIQUE //pierre


	//. --------------------------------------------------------------------------------------
	//. Define 3D-properties
	//. --------------------------------------------------------------------------------------
	rSeqLim.setDimension (SEQ::DIM_3) ;

    dDef= rSeqLim.getBaseResolution().getDef();	
	rSeqLim.setPartition            (   dDef , dDef ,     1,          dDef);
	rSeqLim.setImagesPerSlab        (   dDef,  dDef,    1,          dDef);
    rSeqLim.setSlabThickness        (       0.000,     500.000                          );
    rSeqLim.set3DPartThickness      (       0.0,         10,         0.01,    1);
    rSeqLim.setSliceOversampling    (       0.000,       0.000,       0.000,       0.000);


	//. --------------------------------------------------------------------------------------
	//. Configure user interface: Hide some switches
	//. --------------------------------------------------------------------------------------
	rSeqLim.getEllipticalScanning       ().setDisplayMode (SEQ::DM_OFF);        // Hide the elliptical scanning switch
	rSeqLim.getEPIFactor                ().setDisplayMode (SEQ::DM_OFF);        // Hide EPI-factor
	rSeqLim.getInversion                ().setDisplayMode (SEQ::DM_OFF);        // Hide Inversion
	rSeqLim.getAverages                 ().setDisplayMode (SEQ::DM_OFF);	 	 // Hide Averages
	rSeqLim.getPhaseFOV                 ().setDisplayMode (SEQ::DM_OFF);		 // Hide PhaseFOV
	rSeqLim.disableAAPara();


	//. --------------------------------------------------------------------------------------
	//. Set Limits for Loop control counters
	//. --------------------------------------------------------------------------------------
	rSeqLim.setRepetitions                  (        0,      511,        1,      0  )  ;

	lInc = 100000;
	lMax = 2000000000;
	rSeqLim.setRepetitionsDelayTime         (        0,     lMax,     lInc,        0)  ;
	rSeqLim.setIntro                       (SEQ::OFF);
    rSeqLim.getRadialViews().set("trufi_cv::setRadialViews", 1, 200000, 1, 256, true, 0, false);


	//. --------------------------------------------------------------------------------------
	//. Define properties of excitation
	//. --------------------------------------------------------------------------------------
	rSeqLim.setFlipAngle                        (     5.000,  180.000,    1.000,   15.000)  ;
	rSeqLim.setRFSpoiling (SEQ::ON, SEQ::OFF) ;


	//. --------------------------------------------------------------------------------
	//. Set ADC properties
	//. --------------------------------------------------------------------------------
	rSeqLim.setBandWidthPerPixel        (    0,        80,     10000,       10,         330);
	rSeqLim.setReadoutOSFactor(1.0) ;

	rSeqLim.setExtSrfFilename ("%MEASDAT%/extrf.dat"); // pulse for IRn
	//. -----------------------------------------------------------------------------
	//. Configure Reconstruction / Interpolation
	//. -----------------------------------------------------------------------------
	rSeqLim.set2DInterpolation (SEQ::NO, SEQ::YES);
	rSeqLim.setReconstructionMode (SEQ::RECONMODE_MAGNITUDE, SEQ::RECONMODE_PHASE, SEQ::RECONMODE_MAGN_PHASE);


	//. -----------------------------------------------------------------------------
	//. Adjustment parameters
	//. -----------------------------------------------------------------------------
	rSeqLim.setAdjShim (SEQ::ADJSHIM_TUNEUP,SEQ::ADJSHIM_STANDARD);

	//. --------------------------------------------------------------------------------
	//. Set Phase properties
	//. --------------------------------------------------------------------------------
	rSeqLim.addPhysioMode( SEQ::SIGNAL_CARDIAC, SEQ::METHOD_TRIGGERING);
	rSeqLim.setPhases     ( 1, K_NO_SLI_MAX, 1, 1 );     

	//. --------------------------------------------------------------------------------
	//. Beging ParameterMap
	//. --------------------------------------------------------------------------------
	BEGIN_PARAMETER_MAP(&rSeqLim, 0, 0);


	PARAM("Do Calibration", &u_bDoCalibration, false ,"Do Calibration");	

	PARAM_SELECT("Mode acq",&u_AcqMode, 1 ); 
	OPTION("Uni",1);
	OPTION("GA",2);
	PARAM_SELECT_END();

	PARAM("ADC offset","#s",  &l_offset, 0,10,2,4,"Time between ADC and gradient");
	PARAM("Set amount of spoil","X Gread",  &l_spoilAmp, 0.,10.,1,0.,"Amount of spoiling");

	PARAM_SELECT("Mode",&u_Mode, 1 ); 
	OPTION("GRE",1);
	OPTION("TrueFisp",2);
	PARAM_SELECT_END();

	PARAM("Dummy Scan", &u_dummyScan, false ,"Add 3000 dummy scan for steady state");	

	PARAM("SelfGating", &u_Selfgating, false,"activate the selfgating in gadgetron reconstruction");	
	PARAM_GROUP(); 
	PARAM("Cardiac Phase","",  &l_ECGPhaseNumb, 0.,20.,1,1.,"Set the number of phase that gadgetron has to reconstruct");
	PARAM("Respiratory Phase","",  &l_RESPPhaseNumb, 0.,20.,1,1.,"Set the number of phase that gadgetron has to reconstruct");
	PARAM_GROUP_END();

	PARAM("Dump", &u_bDump, true, "change the ICE program to do the dump");

	PARAM_GROUP();
	PARAM("TI1","ms", &u_lTI1, 100., 10000. , 1., 800.,"Inversion Time for first image");
	PARAM("TI2","ms", &u_lTI2, 100., 10000. , 1., 2200.,"Inversion Time for seconde image");
	PARAM_GROUP_END();

	PARAM("TotalTR","ms", &u_lTotalTR, 100., 10000. , 1., 5000.,"Total relaxtion time");

	PARAM("Echo Train Length","", &u_lETL, 1, 256 , 1, 128,"Calibration square size");

	PARAM("version","",&l_currentVersion, 1., 30.,.1, l_version,"");


	END_PARAMETER_MAP;


	#ifndef VXWORKS
	//rSeqLim.setDefaultEVAProt (_T("%SiemensEvaDefProt%\\Inline\\Inline.evp"));
	#endif
	//  ----------------------------------------------------------------------
	//  Instantiate of UI class
	//  ----------------------------------------------------------------------
	if ( (NLS_SEV & (lStatus = createUI (rSeqLim))) == NLS_SEV )  {
		TRACE_PUT1(TC_ALWAYS, TF_SEQ,"%s: Instantiation of UI class failed: FM_MP2RAGE::createUI(SeqLim&)", ptModule);
		return ( lStatus );
	}

	//  ----------------------------------------------------------------------
	//  Declaration of pointer to UI parameter classes
	//  ----------------------------------------------------------------------

	#ifdef WIN32
	lStatus = m_pUI->registerUI (rSeqLim);

	if ( NLS_SEVERITY(lStatus) != NLS_SUCCESS )  {
		TRACE_PUT1_NLS(TC_INFO, TF_SEQ, "%s : Initialization of UI failed : "  , ptModule, lStatus);
		return ( lStatus );
	}
#endif

	return (lStatus) ;

}








//  --------------------------------------------------------------------------
//
//  Name        :  FM_MP2RAGE::prepare
//
//  Description :
/// \brief         Preparation of the sequence during binary search and prior
///                 to sequence execution
//
//  Return      :  NLS status
//
//  --------------------------------------------------------------------------
NLSStatus FM_MP2RAGE::prepare (MrProt &rMrProt, SeqLim &rSeqLim, SeqExpo &rSeqExpo)
{
	//. -----------------------------------------------------------------------------
	//. Local variables
	//. -----------------------------------------------------------------------------
	static const char *ptModule        = {"fSEQPrep"};    	 // identify Module for error messages
	NLS_STATUS   lStatus               = SEQU__NORMAL;           // My return status: default return status is OK
	MrProtocolData::SeqExpoRFInfo       dRfEnergyInSRFs    ;                  // RF energy in SRF
	double       dMeasureTimeUsec      = 0.0 ;
	//double       dTotalMeasureTimeMsec      = 0.0 ;

	//. ---------------------------------------------------------------------------
	//. prepare parameter map
	//. ---------------------------------------------------------------------------	
	PREPARE_PARAMETER_MAP( &rMrProt,  &rSeqLim);

	DISABLE_PARAM(rSeqLim,  &l_currentVersion );
	//. ---------------------------------------------------------------------------
	//. get info
	//. ---------------------------------------------------------------------------	
	  
	m_lPhasesToMeasure = rMrProt.physiology().phases();    
	m_lSlicesToMeasure = rMrProt.sliceSeries().getlSize();       // get number of slices
	m_lRepetitionsToMeasure = rMrProt.repetitions();         // get number of repetitions
	// Get information about used trigger
	rMrProt.physiology().getPhysioMode (m_FirstSignal, m_FirstMethod, m_SecondSignal, m_SecondMethod);

	// We want to forbid the simultaneous use of Triggering and the 
	//   "TokTokTok Gradient music" (i.e. the knocking before the measurement)
	//   for demonstration of Solve Handlers
	// So this combination must fail and a solve handler 
	//  "fBSolveFunnyModeConflict1" is called if
	//  the conflict was induced by switching "Introduction" on.
	if ( (rMrProt.intro()) && (m_FirstMethod == SEQ::METHOD_TRIGGERING) )
	return SEQU_ERROR ;


	//if (!m_SBBCALIB.prep( rMrProt, rSeqLim,rSeqExpo))
	//	return SEQU_ERROR ;

	double dReallySmallestRiseTime =  5.;
    double dReallyBiggestAmplitude = 28.;

        // These arrays take the MaxAmplitude and MinRiseTime values for the Sequence Building Blocks (SBB)
        //  Order: FAST/NORMAL/WHISPER
                                    // Default factor is 1.25 on GRAD_FAST, 1.0 on GRAD_NORMAL and GRAD_WHISPER
    double  adMinRiseTimes[3] =  {   std::max( 1.25 * SysProperties::getGradMinRiseTime(SEQ::GRAD_FAST   ),dReallySmallestRiseTime),
                                     std::max( 1.0 * SysProperties::getGradMinRiseTime(SEQ::GRAD_NORMAL ),dReallySmallestRiseTime),
                                     std::max( 0.8 * SysProperties::getGradMinRiseTime(SEQ::GRAD_WHISPER),dReallySmallestRiseTime)
                                 };

                                    // Default factor is 1.0
    double  adMaxGradAmplitudes[3] =  {  std::min( 1.0 * SysProperties::getGradMaxAmpl(SEQ::GRAD_FAST   ),dReallyBiggestAmplitude),
                                         std::min( 0.8 * SysProperties::getGradMaxAmpl(SEQ::GRAD_NORMAL ),dReallyBiggestAmplitude),
                                         std::min( 0.65 * SysProperties::getGradMaxAmpl(SEQ::GRAD_WHISPER),dReallyBiggestAmplitude)
                                 };

	//. ---------------------------------------------------------------------------
	//. Define gradient rise times and strengths
	//. ---------------------------------------------------------------------------
	m_dMinRiseTime = 1.25 * SysProperties::getGradMinRiseTime(rMrProt.gradSpec().mode());
	m_dGradMaxAmpl = 0.9 * SysProperties::getGradMaxAmpl(rMrProt.gradSpec().mode());


if (rMrProt.gradSpec().isGSWDMode()) m_dMinRiseTime =  rMrProt.gradSpec().GSWDMinRiseTime();


	//. ---------------------------------------------------------------------------
	//. Prepare the RF pulse objects (Copied from UTE WIP)
	//. ---------------------------------------------------------------------------
	m_sSRF.setThickness            (10000.0);                        // This is just a dummy slice thickness
	m_sSRF.setTypeExcitation       ();                               // Resets all moments to 0 in Unit test
	m_sSRF.setDuration             (60);                            // Most times are in microseconds
	m_sSRF.setFlipAngle            (rMrProt.flipAngle());           // Sets flip angle based on UI (in degrees)
	m_sSRF.setInitialPhase         (0);                              // Sets phase of pulse in rotating frame to 0 (+x) 
	m_sSRF.setSamples              (60);   

	// tell unit test that the thickness of the RF pulse is set to the sat thickness on purpose
#ifndef VXWORKS

	SeqUT.setRFThicknessInfo ( &m_sSRF, 10000.0 );
#endif
	if (!m_sSRF.prepRect(rMrProt,rSeqExpo)) return (m_sSRF.getNLSStatus());


	//. -------------------------------------------------------------------------------
	//. Keep the FOV 3D isotropic
	//. -------------------------------------------------------------------------------
	rMrProt.kSpace().imagesPerSlab(rMrProt.kSpace().baseResolution());
	// make matrix the same in all directions
	rMrProt.kSpace().phaseResolution (1.0);
	rMrProt.kSpace().sliceResolution (1.0);

	rMrProt.kSpace().setucTrajectory(SEQ::TRAJECTORY_RADIAL);

	rMrProt.kSpace().radialInterleavesPerImage(1);
	u_Projections = rMrProt.kSpace().radialViews();
	
	// make slice thickness = in-plane voxel size (tricky - cast away the const to avoid compiler errors) 
	const_cast<Slice*>(&rMrProt.sliceSeries()[0])->thickness( rMrProt.sliceSeries()[0].readoutFOV() );
	rMrProt.tablePositioningMode(SEQ::TP_POS_MODE_ISO);	

	//. -------------------------------------------------------------------------------
	//. Prepare readout (ADC) objects
	//. -------------------------------------------------------------------------------



	//double dReadAsymmetry = 0;// 100% asymmetric
	long lColumns = (long) ((rMrProt.kSpace().baseResolution())); // + l_offset;

	m_sADC[0].prep(lColumns, static_cast<long>(rMrProt.rxSpec().effDwellTime( rSeqLim.getReadoutOSFactor() )[0] ));

	//. -------------------------------------------------------------------------------
	//. Calculation of Gradient Amplitude
	//. -------------------------------------------------------------------------------
	double rampTime = 300;//TODO correct FOV depending on the rampsampling
	double GradientAmplitudeFOV= 1e9/(rMrProt.sliceSeries()[0].readoutFOV()*m_sADC[0].getDwellTime()*m_sSRF.getLarmorConst());

	m_lRCColumn = lColumns;

	m_sADC[0].prep(lColumns, static_cast<long>(rMrProt.rxSpec().effDwellTime( rSeqLim.getReadoutOSFactor() )[0] ));

	
	m_sSgADC[0].prep(l_offset, static_cast<long>(rMrProt.rxSpec().effDwellTime( rSeqLim.getReadoutOSFactor() )[0] ));		


	m_SBBCALIB.getNbpoints(m_lRCColumn);
	m_SBBCALIB.getRadial(true);

	//. -------------------------------------------------------------------------------
	//. Prepare phase gradient pulse
	//. -------------------------------------------------------------------------------
	m_sGradPhase.setMaxMagnitude(m_dGradMaxAmpl);
	m_sGradPhase.setMinRiseTime (fSDSRoundUpGRT(m_dMinRiseTime));
	m_sGradPhase.setRampTimes(fSDSRoundUpGRT(rampTime));

	m_sGradPhase.setDuration  (fSDSRoundUpGRT(rampTime + m_sADC[0].getDuration())) ;/*! EGA-03; EGA-01 !*/
	m_sGradPhase.prepAmplitude(GradientAmplitudeFOV);	

	//. -------------------------------------------------------------------------------
	//. Slice phase gradient pulse
	//. -------------------------------------------------------------------------------
	m_sGradSlice.setMaxMagnitude(m_dGradMaxAmpl);
	m_sGradSlice.setMinRiseTime (m_dMinRiseTime);
	m_sGradSlice.setRampTimes(fSDSRoundUpGRT(rampTime));

	m_sGradSlice.setDuration  (fSDSRoundUpGRT(rampTime + m_sADC[0].getDuration() )) ;  /*! EGA-03; EGA-01 !*/
	m_sGradSlice.prepAmplitude(GradientAmplitudeFOV);

	//. -------------------------------------------------------------------------------
	//. read phase gradient pulse
	//. -------------------------------------------------------------------------------
	m_sGradRead.setMaxMagnitude(m_dGradMaxAmpl);
	m_sGradRead.setMinRiseTime (m_dMinRiseTime);
	m_sGradRead.setRampTimes(fSDSRoundUpGRT(rampTime));
	m_sGradRead.prepAmplitude(GradientAmplitudeFOV);

	m_sGradRead.setDuration(fSDSRoundUpGRT(rampTime + m_sADC[0].getDuration()));
	readMoment = m_sGradRead.getMomentumTOT();

	if (!m_sGradRead.check()) return (m_sGradRead.getNLSStatus());
	if (!m_sGradSlice.check()) return (m_sGradSlice.getNLSStatus());
	if (!m_sGradPhase.check()) return (m_sGradPhase.getNLSStatus());
	std::cout<< "ADC sg Duration = " << m_sSgADC[0].getDuration()<< std::endl;
	//. -------------------------------------------------------------------------------
	//. read dephase gradient pulse																	FM
	//. -------------------------------------------------------------------------------
		m_sGradReadDephFM.setMaxMagnitude(m_dGradMaxAmpl);
		m_sGradReadDephFM.setMinRiseTime (m_dMinRiseTime);
		m_sGradReadDephFM.setRampTimes(fSDSRoundUpGRT(rampTime));

		double duration = 0.5*m_sGradRead.getDuration()*GradientAmplitudeFOV/m_dGradMaxAmpl;
		duration = fSDSRoundUpGRT(duration);
		double DephGradAmpl = m_sGradSlice.getMomentumTOT()/(2*duration);

		m_sGradReadDephFM.setDuration (duration);
		m_sGradReadDephFM.prepAmplitude(DephGradAmpl);

		if (!m_sGradReadDephFM.check()) return (m_sGradReadDephFM.getNLSStatus());

	//. -------------------------------------------------------------------------------
	//. phase dephase gradient pulse																	FM
	//. -------------------------------------------------------------------------------
		m_sGradPhaseDephFM.setMaxMagnitude(m_dGradMaxAmpl);
		m_sGradPhaseDephFM.setMinRiseTime (m_dMinRiseTime);
		m_sGradPhaseDephFM.setRampTimes(fSDSRoundUpGRT(rampTime));

		m_sGradPhaseDephFM.setDuration (duration);
		m_sGradPhaseDephFM.prepAmplitude(DephGradAmpl);

		if (!m_sGradPhaseDephFM.check()) return (m_sGradPhaseDephFM.getNLSStatus());

	//. -------------------------------------------------------------------------------
	//. slice dephase gradient pulse																	FM
	//. -------------------------------------------------------------------------------
		m_sGradSliceDephFM.setMaxMagnitude(m_dGradMaxAmpl);
		m_sGradSliceDephFM.setMinRiseTime (m_dMinRiseTime);
		m_sGradSliceDephFM.setRampTimes(fSDSRoundUpGRT(rampTime));

		m_sGradSliceDephFM.setDuration (duration);
		m_sGradSliceDephFM.prepAmplitude(DephGradAmpl);

		/*std::cout << "--------------------------------------------------" << std::endl;
		std::cout << "slice deph moment = " << 2*m_sGradSliceDephFM.getMomentumTOT() << std::endl;
		std::cout << "slice moment      = " << m_sGradSlice.getMomentumTOT() << std::endl;*/

		if (!m_sGradSliceDephFM.check()) return (m_sGradSliceDephFM.getNLSStatus());

	//. -------------------------------------------------------------------------------
	//. read rephase gradient pulse																	FM
	//. -------------------------------------------------------------------------------
		m_sGradReadRephFM.setMaxMagnitude(m_dGradMaxAmpl);
		m_sGradReadRephFM.setMinRiseTime (m_dMinRiseTime);
		m_sGradReadRephFM.setRampTimes(fSDSRoundUpGRT(rampTime));

		m_sGradReadRephFM.prepSymmetricTOTShortestTime(readMoment + m_sGradReadDephFM.getMomentumTOT());
		/*m_sGradReadRephFM.setDuration (duration);
		m_sGradReadRephFM.prepAmplitude(DephGradAmpl);*/

		if (!m_sGradReadRephFM.check()) return (m_sGradReadRephFM.getNLSStatus());

	//. -------------------------------------------------------------------------------
	//. phase rephase gradient pulse																	FM
	//. -------------------------------------------------------------------------------
		m_sGradPhaseRephFM.setMaxMagnitude(m_dGradMaxAmpl);
		m_sGradPhaseRephFM.setMinRiseTime (m_dMinRiseTime);
		m_sGradPhaseRephFM.setRampTimes(fSDSRoundUpGRT(rampTime));

		m_sGradPhaseRephFM.setDuration (duration);
		m_sGradPhaseRephFM.prepAmplitude(DephGradAmpl);

		if (!m_sGradPhaseRephFM.check()) return (m_sGradPhaseRephFM.getNLSStatus());

	//. -------------------------------------------------------------------------------
	//. slice rephase gradient pulse																	FM
	//. -------------------------------------------------------------------------------
		m_sGradSliceRephFM.setMaxMagnitude(m_dGradMaxAmpl);
		m_sGradSliceRephFM.setMinRiseTime (m_dMinRiseTime);
		m_sGradSliceRephFM.setRampTimes(fSDSRoundUpGRT(rampTime));

		m_sGradSliceRephFM.setDuration (duration);
		m_sGradSliceRephFM.prepAmplitude(DephGradAmpl);

		if (!m_sGradSliceRephFM.check()) return (m_sGradSliceRephFM.getNLSStatus());

	//. -------------------------------------------------------------------------------
	//. sGSpoil gradient pulse
	//. -------------------------------------------s------------------------------------	
	double dSpoilMomRO = l_spoilAmp * m_sGradRead.getMomentumTOT();
	m_sGSpoil.setMaxMagnitude(m_dGradMaxAmpl );
	m_sGSpoil.setMinRiseTime (m_dMinRiseTime );
	if (!m_sGSpoil.prepSymmetricTOTShortestTime(dSpoilMomRO)) return (m_sGSpoil.getNLSStatus());
	if (!m_sGSpoil.check() ) return (m_sGSpoil.getNLSStatus());

	//. ---------------------------------------------------------------------------
	//. Initialization of GradTab for ute sampling
	//. ---------------------------------------------------------------------------    
	double beta;
	double alpha;
	double beta1=0;
	double hn=0;
	double ph1;
	double ph2;
	double phi;
	double theta;
	int proj_traj = 0;

	std::cout<< "u_lETL =" << u_lETL << std::endl;
	std::cout<< "u_Projections =" << u_Projections << std::endl;
	
	

	repetitions =      ceil((float) u_Projections/u_lETL);
	std::cout<<" Repetitions = " << repetitions << std::endl;

	m_MP2Projections = u_lETL * repetitions;

	std::cout<< "m_MP2Projections =" << m_MP2Projections << std::endl;
	if (m_MP2Projections < 200000)
		u_Projections = m_MP2Projections;

	std::cout << "Nombre projections requise = " << u_Projections << std::endl;
	std::cout << "Nombre gradients requis = " << repetitions*u_lETL << std::endl;
	if (u_AcqMode == 1){
		proj_traj = 2*u_Projections;
	}
	else{
		proj_traj = u_Projections;
	}

	for ( int i=0;i < u_Projections; i++)		
	{

		hn=-1+(2*i)/(double(proj_traj)-1);
		alpha=acos(hn);

		if((i==0)||i==(proj_traj-1)){
			beta=0;
		}
		else{
			beta=fmod((float)beta1+3.6/sqrt((float)proj_traj*(1-hn*hn)),2*M_PI);
		}

		beta1=beta;
		Gradx[i]=cos(beta)*sin(alpha)*GradientAmplitudeFOV;
		Grady[i]=sin(beta)*sin(alpha)*GradientAmplitudeFOV;
		Gradz[i]=cos(alpha)*GradientAmplitudeFOV;

		GradxDeph[i]=cos(beta)*sin(alpha)*DephGradAmpl;
		GradyDeph[i]=sin(beta)*sin(alpha)*DephGradAmpl;
		GradzDeph[i]=cos(alpha)*DephGradAmpl;		

	}

	//. Initialization of GradTab for Radial sampling.


	//. ---------------------------------------------------------------------------
	//. Initialization of GradTab for ute sampling with Golden Angle reordering
	//. ---------------------------------------------------------------------------    
	if(u_AcqMode==1 && u_Projections!=200000 && dummy!=u_Projections){
		for ( int i=0;i < proj_traj; i++)		
		{
			Gradx[i] = (long double) (pow( (double)(-1),  i)) *Gradx[i];
			Grady[i] = (long double) (pow( (double)(-1),  i)) *Grady[i];
			Gradz[i] = (long double) (pow( (double)(-1),  i)) *Gradz[i];

			GradxDeph[i] = (long double) (pow( (double)(-1),  i)) *GradxDeph[i];
			GradyDeph[i] = (long double) (pow( (double)(-1),  i)) *GradyDeph[i];
			GradzDeph[i] = (long double) (pow( (double)(-1),  i)) *GradzDeph[i];
		}
	}


	

	//. ---------------------------------------------------------------------------
	//. Initialization of GradTab for ute sampling with original Golden Angle
	//. ---------------------------------------------------------------------------  

	if(u_AcqMode==2 && u_Projections!=200000 && dummy!=u_Projections ){
			for ( int i=0;i < u_Projections; i++){
				alpha =acos(fmod(0.4656*i,1));
				if (fmod((float)i,(float)2))
					alpha=alpha+M_PI;

		 		beta=2*M_PI*fmod(0.6823*i,1);
				Gradx[i]=cos(beta)*sin(alpha)*GradientAmplitudeFOV;
				Grady[i]=sin(beta)*sin(alpha)*GradientAmplitudeFOV;
				Gradz[i]=cos(alpha)*GradientAmplitudeFOV;

				GradxDeph[i]=cos(beta)*sin(alpha)*DephGradAmpl;
				GradyDeph[i]=sin(beta)*sin(alpha)*DephGradAmpl;
				GradzDeph[i]=cos(alpha)*DephGradAmpl;
		}

	}
	
	//. ----------------------------------------------------------------------------
	//. Preparation of TokTokTok gradient sound prior to measurement
	//. ----------------------------------------------------------------------------
	m_TokTokSBB.setRequestsPerMeasurement (1);

	if (!m_TokTokSBB.prep(rMrProt,rSeqLim,rSeqExpo))
	return m_TokTokSBB.getNLSStatus();

	//. ----------------------------------------------------------------------------
    //. Preparation of non selective  Inversion Pulse
    //. ----------------------------------------------------------------------------
	
	    // Tell, how many Inversion pulses would be used during the measurement
        //  (needed for calculation of energy and time)
    m_IRns.setRequestsPerMeasurement (3);
 //       // The spoiler gradient inside the SBB can be configured / limited
 //       //  for the selected gradient mode
 //       // An array with the maximum amplitudes for FAST/NORMAL/WHISPER is handed over
 //       // If not set, a default is used.
    m_IRns.setMaxMagnitudes(adMaxGradAmplitudes);
 //       // ditto for the minimum rise time
    m_IRns.setMinRiseTimes (adMinRiseTimes);


 //       // Tell the SBB to use the longer rise times in case of a GSWD binary search
 //       // NOTE: This method has to be called for every SeqBuildBlock you use.
    m_IRns.setGSWDGradientPerformance(rMrProt, rSeqLim);
        // prepare the saturation SBB
	if(! m_IRns.IRprep(rMrProt, rSeqLim, rSeqExpo))
	{
		TRACE_PUT1_NLS(TC_INFO, TF_SEQ, "%s: m_IRns.prep failed.",ptModule,m_IRns.getNLSStatus());
		return m_IRns.getNLSStatus();
	}

	//. ----------------------------------------------------------------------------
    //. Calculate Delay Fill-times and check, whether timing can be realized // Ajout Aurï¿½lien TROTIER
    //. ----------------------------------------------------------------------------
	double minDelayTI1 = u_Projections * rMrProt.tr()[0]/2;	
	//CHANGE_LIMITS(&u_lTI1,(long) (minDelayTI1/1000.0),(long) 10000.,(long) 1.);
	m_dDelayTI1 = u_lTI1 - minDelayTI1/1000;

	double minDelayTI2 = u_Projections * rMrProt.tr()[0] * 1.5 + m_dDelayTI1;
	m_dDelayTI2 = u_lTI2 - minDelayTI2/1000;

	double minDelayTR = 2 * u_Projections * rMrProt.tr()[0] + m_dDelayTI1 + m_dDelayTI2;
	m_dDelayTR  = u_lTotalTR - minDelayTR/1000            ;  // delay between GRE train 2 and total TR
	
	if(m_dDelayTI1 < 0)
		u_lTI1 = minDelayTI1/1000;
	if(m_dDelayTI2 < 0)
		u_lTI2 = minDelayTI2/1000;
	if(m_dDelayTR < 0)
		u_lTotalTR = minDelayTR/1000;

	//. ----------------------------------------------------------------------------
	//. Calculate TEFill-times and check, whether timing can be realized
	//. ----------------------------------------------------------------------------

	MinDurationBetweenADCandRF = 1.2 * SysProperties::getMinDurationBetweenRFPulseAndReadout();
	MinDurationBetweenRFandADC = 40;// FM_MP2RAGE WIP SIEMENS
	m_lTEMin = m_sSRF.getDuration()/2 + fSDSRoundUpGRT(m_sSgADC[0].getDuration()) + m_sGradReadDephFM.getTotalTime() + m_sGradRead.getTotalTime()/2 + MinDurationBetweenRFandADC;

	std::cout << "TE Min = " << m_lTEMin << std::endl;
	std::cout <<" TE Min UT = " << m_sSRF.getDuration()/2 + m_sSgADC[0].getDuration()/2 << std::endl;
	m_alTEFil[0] = rMrProt.te()[0] - m_lTEMin;
		//m_alTEFil[ 0] = rMrProt.te()[0]  - (m_sSRF.getDuration()/2 + MinDurationBetweenRFandADC);

		if ( m_alTEFil[ 0] < 0 )
			if (rSeqLim.isContextPrepForMrProtUpdate())
				rMrProt.te()[0] += fSDSRoundUpGRT( -m_alTEFil[ 0]);
			else
				return SBB_NEGATIV_TEFILL ;
		m_alTEFil[ 0] = fSDSRoundUpGRT(m_alTEFil[ 0]);



	std::cout << "TE min =" <<m_lTEMin;
	//. ----------------------------------------------------------------------------
	//. Calculate minimum TR and check, whether timing can be realized
	//. ----------------------------------------------------------------------------	

	m_lTRMin = rMrProt.te()[0] + m_sSRF.getDuration()/2 +m_sGradRead.getTotalTime()/2 + max(m_sGradReadRephFM.getTotalTime(),m_sGradPhaseRephFM.getTotalTime()) + 100;


	std::cout << "m_lTR Min = " << m_lTRMin << std::endl;
	std::cout << "rMrProt.te()[0] = " << rMrProt.te()[0] << std::endl;
	std::cout << "fSDSRoundUpGRT(m_sSRF.getDuration()/2) = " << fSDSRoundUpGRT(m_sSRF.getDuration()/2) << std::endl;
	std::cout << "fSDSRoundUpGRT(m_sGradRead.getTotalTime()/2) = " << fSDSRoundUpGRT(m_sGradRead.getTotalTime()/2) << std::endl;
	std::cout << "max(m_sGradReadRephFM.getTotalTime(),m_sGradPhaseRephFM.getTotalTime()) = " << max(m_sGradReadRephFM.getTotalTime(),m_sGradPhaseRephFM.getTotalTime()) << std::endl;
	std::cout << "m_sGradReadRephFM.getTotalTime() = " << m_sGradReadRephFM.getTotalTime() << std::endl;
	std::cout << "m_sGradPhaseRephFM.getTotalTime() = " << m_sGradPhaseRephFM.getTotalTime() << std::endl;


	if(u_Mode==2)
		m_lTRMin +=  m_sGradRead.getTotalTime(); 


	if ( rMrProt.tr()[0] < m_lTRMin )
		//if (rSeqLim.isContextPrepForMrProtUpdate())
			rMrProt.tr()[0] = 	fSDSRoundUpGRT(m_lTRMin);
		//else
		//return SBB_NEGATIV_TRFILL ;


	//. ----------------------------------------------------------------------------
	//. Set m_lTrigHaltDuration1 and m_lTrigHaltDuration2
	//. ----------------------------------------------------------------------------	
  m_lTrigHaltDuration1 = m_lTrigHaltDuration2 = 0;
    if (m_FirstMethod == SEQ::METHOD_TRIGGERING)
    {
        DEBUG_BY_REGISTRY( 128,"---- Trigger 1 is on, Method " << m_FirstMethod );
        m_lTrigHaltDuration1 =  std::max<long>((long)(rMrProt.physiology().triggerDelay(m_FirstSignal)), (long)(m_sTriggerBit1.getDuration()) + 10);
        if (m_SecondMethod == SEQ::METHOD_TRIGGERING)
        {
            m_lTrigHaltDuration2 =  std::max<long>((long)(rMrProt.physiology().triggerDelay(m_SecondSignal)), (long)(m_sTriggerBit2.getDuration()) + 10);
        }
    }

	//. ----------------------------------------------------------------------------
	//.  calculation dMeasureTimeUsec
	//. ----------------------------------------------------------------------------	
	double m_lKernelRequestsPerMeasurement= m_lPhasesToMeasure * m_lSlicesToMeasure  * u_Projections  * rMrProt.averages();
	std::cout << "nbkernel == "<< m_lKernelRequestsPerMeasurement << std::endl;
	if(u_dummyScan)
		m_lKernelRequestsPerMeasurement+=3000;

	dMeasureTimeUsec = m_lKernelRequestsPerMeasurement * rMrProt.tr()[0] ;
	//dMeasureTimeUsec += m_lKernelRequestsPerMeasurement * (m_lTrigHaltDuration1 + m_lTrigHaltDuration2)/ u_Projections;

	//. ----------------------------------------------------------------------------
	//.  calculation m_dTotalMeasureTimeUsec
	//. ----------------------------------------------------------------------------	
	//lStatus=fSBBMeasRepetDelaysPrep(rMrProt, rSeqLim, rSeqExpo,
 //                                 (dMeasureTimeUsec/1000.),
 //                                 &dTotalMeasureTimeMsec);
 //   OnErrorPrintAndReturn(lStatus,"fSBBMeasRepetDelaysPrep");

  // double m_dTotalMeasureTimeUsec = dTotalMeasureTimeMsec * 1000.0;

	double m_dTotalMeasureTimeUsec=0.0;
	m_dTotalMeasureTimeUsec =  dMeasureTimeUsec * (m_lRepetitionsToMeasure + 1);
	m_dTotalMeasureTimeUsec += (double) m_TokTokSBB.getDurationPerRequest();

	if(u_bDoCalibration)
	m_dTotalMeasureTimeUsec += (double) m_SBBCALIB.getDurationPerRequest(); 
    if ( (rMrProt.getsPhysioImaging().getlMethod1() == SEQ::METHOD_TRIGGERING) &&
         (rMrProt.physiology().triggerPulses (rMrProt.getsPhysioImaging().getlSignal1()) > 1)       
       )
    {
        MrPhysiology myPhysioWrapper(rMrProt.getsPhysioImaging());

        long lTriggerLockTime_us = rMrProt.physiology().triggerDelay(rMrProt.getsPhysioImaging().getlSignal1()) + rMrProt.getalTR()[0];
         rMrProt.getsPhysioImaging().setlTriggerLockTime( lTriggerLockTime_us ); // needed by UT

        long lPhysioHalts = (m_lRepetitionsToMeasure + 1)  * m_lPhasesToMeasure *  rMrProt.averages() * m_lSlicesToMeasure ;

        m_dTotalMeasureTimeUsec +=  double( lTriggerLockTime_us * lPhysioHalts* (rMrProt.physiology().triggerPulses (rMrProt.getsPhysioImaging().getlSignal1()) - 1) );
    }

	//. ----------------------------------------------------------------------------
	//.  update correction secan time 
	//. ----------------------------------------------------------------------------		
    rSeqExpo.setPreScans               (3000);   
    rSeqExpo.setRelevantReadoutsForMeasTime ( m_lPhasesToMeasure * m_lSlicesToMeasure  * u_Projections  * rMrProt.averages());

	//. ----------------------------------------------------------------------------
	//.  calculation dRfEnergyInSRFs
	//. ----------------------------------------------------------------------------		
	dRfEnergyInSRFs  = m_lKernelRequestsPerMeasurement * m_sSRF.getRFInfo()  * (rMrProt.repetitions()+1); // should i add RF info of SBBCALIB (Aurel)
	if(u_bDoCalibration)
	dRfEnergyInSRFs = m_SBBCALIB.getRFInfoPerRequest() + dRfEnergyInSRFs;

	//std::cout << "Energy SBB" << m_SBBCALIB.getRFInfoPerRequest() << std::endl;

	//. ------------------------------------------------------------------------
	//. Set the receiver gain: For thin slices use high receiver gain
	//. ------------------------------------------------------------------------
	lStatus = fSSLSetRxGain( fSURxGainCode(rMrProt, rSeqLim, THICKNESSmm_RxGain, GRE_Sequence) , rMrProt, rSeqLim);
	OnErrorPrintAndReturn(lStatus,"fSSLSetRxGain");

	//. ---------------------------------------------------------------------------
	//. Calculate the rotation matrices and positions for slices
	//. ---------------------------------------------------------------------------
	lStatus = fSUPrepSlicePosArray (rMrProt, rSeqLim, m_asSLC);
	OnErrorPrintAndReturn (lStatus,  "fSUPrepSlicePosArray");

	//. ---------------------------------------------------------------------------
	//. Export information to rSeqExpo
	//. ---------------------------------------------------------------------------
	fSUSetSequenceString ("fl", rMrProt, rSeqExpo); // tell the basic sequence string
	rSeqExpo.setMeasured3dPartitions(1);
    rSeqExpo.setRFInfo(dRfEnergyInSRFs );
	rSeqExpo.setMeasureTimeUsec (dMeasureTimeUsec);
	rSeqExpo.setTotalMeasureTimeUsec(m_dTotalMeasureTimeUsec );
	rSeqExpo.setMeasuredPELines(u_Projections);

	//. ---------------------------------------------------------------------------
	//. Set ICE Program parameters:
	//. ---------------------------------------------------------------------------
	if (!u_Selfgating && !u_bDump)
		rSeqLim.setICEProgramFilename  ("%CustomerIceProgs%\\IceProgramGadgetronUTE");
	else if(u_bDump)
		rSeqLim.setICEProgramFilename  ("%CustomerIceProgs%\\IceProgramGadgetronUTE_Dump");
	else
		rSeqLim.setICEProgramFilename  ("%CustomerIceProgs%\\IceProgramGadgetronUTE_SG");

	rSeqExpo.setOnlineFFT          (SEQ::ONLINE_FFT_NONE); // default: no Online FFTs except ROFT
	rSeqExpo.setICEProgramParam    (ICE_PROGRAM_PARA_SHOW_OFFLINE, SEQ::SO_SHOW_YES);
	rSeqExpo.setSlicePerConcat (1);


	//. ---------------------------------------------------------------------------
	//. Send in-plane offcenter to gadgetron
	//. ---------------------------------------------------------------------------    
	rSeqExpo.setICEProgramParam(ICE_PROGRAM_PARA_USER_0,m_asSLC[0].getSliceOffCenterRO());
	rSeqExpo.setICEProgramParam(ICE_PROGRAM_PARA_USER_1,m_asSLC[0].getSliceOffCenterPE());
	rSeqExpo.setICEProgramParam(ICE_PROGRAM_PARA_USER_2,l_offset);
	rSeqExpo.setICEProgramParam(ICE_PROGRAM_PARA_USER_3,u_AcqMode);
	rSeqExpo.setICEProgramParam(ICE_PROGRAM_PARA_USER_4,l_ECGPhaseNumb);
	rSeqExpo.setICEProgramParam(ICE_PROGRAM_PARA_USER_4,l_RESPPhaseNumb);
	rSeqExpo.setApplicationCard(SEQ::APPLICATION_CARD_INLINE);

	if (l_offset>0)
	{
		rSeqExpo.setNSet(2);
		SeqUT.setSizeOfDimSet(2);
		SeqUT.setTestTEOnlyForSet(1);
	}
	else
		rSeqExpo.setNSet(1);

	//SeqUT.DisableTestCase(NoGrInXErr, RTEB_ORIGIN_fSEQRunFinish,"Test");
	//SeqUT.DisableTestCase(MoreGrInXErr, RTEB_ORIGIN_fSeqRunFinish,"Test");
	//SeqUT.DisableTestCase(EndNoParalNCOErr, RTEB_ORIGIN_fSeqRunFinish,"Test");
	SeqUT.DisableTestCase(lNoAddDimCheckedMomentErr, RTEB_ORIGIN_fSEQRunFinish,"Test");
	SeqUT.DisableTestCase(lGsMomentNotRephasedErr, RTEB_ORIGIN_fSEQRunFinish,"Test");
	


	//. ---------------------------------------------------------------------------
	//. update parameter map
	//. ---------------------------------------------------------------------------	
	/*if(!u_Selfgating){
	    DISABLE_PARAM(rSeqLim,  &l_ECGPhaseNumb );	   
        HIDE_PARAM(rSeqLim, &l_ECGPhaseNumb);
		DISABLE_PARAM(rSeqLim,  &l_RESPPhaseNumb );	   
        HIDE_PARAM(rSeqLim, &l_RESPPhaseNumb);
		l_ECGPhaseNumb  =0;
		l_RESPPhaseNumb =0;
	}*/
	/*else{
		ENABLE_PARAM(rSeqLim,  &l_ECGPhaseNumb );	   
        SHOW_PARAM(rSeqLim, &l_ECGPhaseNumb);	
		ENABLE_PARAM(rSeqLim,  &l_RESPPhaseNumb );	   
        SHOW_PARAM(rSeqLim, &l_RESPPhaseNumb);			
	}*/

	UPDATE_PROTOCOL(&rMrProt, &rSeqLim);

	//. ---------------------------------------------------------------------------
	//. End of sequence preparation
	//. ---------------------------------------------------------------------------
	DEBUG_BY_REGISTRY( 128, "  everything prepped! ");
	if ( lStatus == SEQU__NORMAL ) DEBUG_BY_REGISTRY( 128, "  SEQU_NORMAL ");;
	return (lStatus) ;

}

//  -------------------------------------------------------------------------
//
//  Name        :  FM_MP2RAGE::check
//
//  Description :
/// \brief         Check of the sequence for gradient stimulation
///
///                This method is called by the framework prior to a
///                 measurement on the host to ensure, that
///                 - no gradient overflow occurs
///                 - the stimulation will not exceed the threshold
///
//  Return      :  NLS status
//
//  --------------------------------------------------------------------------
NLSStatus FM_MP2RAGE::check (MrProt  &rMrProt, SeqLim &rSeqLim, SeqExpo &rSeqExpo, SEQCheckMode *pSEQCheckMode)
{

	#ifndef VXWORKS //avoid warning for unsed pSEQCheckMode
	SEQCheckMode *dummy ; dummy = pSEQCheckMode ;
	#endif

	//. --------------------------------------------------------
	//. Local variables
	//. --------------------------------------------------------
	static const char *ptModule  = {"fSEQCheck"}; // Name of this module
	NLS_STATUS   lStatus         = SEQU__NORMAL;

	mPrintTrace0 (DEBUG_CHECK, DEBUG_CALL, "() >>>>") ;
	long        lChronologicSlice= 0 ;
	long 	    lL = 0;
	long        lPartition=0;


	//. --------------------------------------------------------
	//. Loop over extreme k-space-points and call fSEQRunKernel
	//. --------------------------------------------------------
	while ( (lL != 1) && (((lStatus) & NLS_SEV) == NLS_SUCCESS) )
	{	
	    //. ---------------------------------------------------------------------------
		//. Dummy scan
		//. ---------------------------------------------------------------------------
		if(u_dummyScan){
			for(unsigned int j=0; j<3000;j++){
			   lStatus=runKernel( rMrProt, rSeqLim, rSeqExpo, KERNEL_PREPARE, 0,0,0);  
			}
		}
	   	for(  int k=0; k < u_Projections ;k++){		
			lStatus=runKernel( rMrProt, rSeqLim, rSeqExpo,KERNEL_CHECK,  k, lChronologicSlice,lPartition); 
		 }	
		 lL=1;
	}

	mPrintTrace0 (DEBUG_CHECK, DEBUG_RETURN, "() <<<<") ;

	return(lStatus);

}



//  --------------------------------------------------------------------------
//
//  Name        :  FM_MP2RAGE::run
//
//  Description :
///     \brief     Execution of the sequence
//
//  Return      :  NLS status
//
//  --------------------------------------------------------------------------
NLSStatus FM_MP2RAGE::run (MrProt &rMrProt, SeqLim &rSeqLim, SeqExpo &rSeqExpo)
{
	//. --------------------------------------------------------
	//. Local variables
	//. --------------------------------------------------------
	static const char *ptModule = {"fSEQRun"};
	NLS_STATUS lStatus          = SEQU__NORMAL;
    long       lPhase=0;
	long       lChronologicSlice=0;
	long       lPartition=0 ;
	long       lRepetition =0;


	mPrintTrace1 (DEBUG_RUN, DEBUG_CALL, "() <%s> started", rSeqLim.getLinkedSeqFilename() ) ;

	// Initialization of the unit test function
	mSEQTest(rMrProt,rSeqLim,rSeqExpo,RTEB_ORIGIN_fSEQRunStart,0,0,0,0,0); /*! EGA-All !*/


	//. --------------------------------------------------------------------------
	//. Set the  getMDH() parameters
	//. --------------------------------------------------------------------------
	
		m_sADC[0].getMDH().setKSpaceCentreLineNo((int)u_Projections/2); // (= Base Resolution / 2).
		m_sADC[0].getMDH().setKSpaceCentrePartitionNo (0);
		m_sADC[0].getMDH().setKSpaceCentreColumn (rMrProt.kSpace().getlBaseResolution()/2);
	

		m_sSgADC[0].getMDH().setKSpaceCentreLineNo((int)u_Projections/2); // (= Base Resolution / 2).
		m_sSgADC[0].getMDH().setKSpaceCentrePartitionNo (0);
		m_sSgADC[0].getMDH().setKSpaceCentreColumn (rMrProt.kSpace().getlBaseResolution()/2);


	//. ---------------------------------------------------------------------------
	//. Make the TokTokTok gradient sound at start of measurement
	//. ---------------------------------------------------------------------------    
	//if (rMrProt.intro()) 
	if (! m_TokTokSBB.run(rMrProt, rSeqLim, rSeqExpo, &m_asSLC[0]) ) return (m_TokTokSBB.getNLSStatus()) ;  


	//. ---------------------------------------------------------------------------
	//. Initialisation of acquisition parameters
	//. ---------------------------------------------------------------------------
	int CurrentProjection = 0;

	if (m_FirstSignal!=1)
	MaxProjectionInPhase = (int)(((float)rMrProt.physiology().EKG().getlScanWindow()-rMrProt.physiology().EKG().getlTriggerDelay()/1000.0)/(float)m_lPhasesToMeasure)/((float)rMrProt.tr()[0]/1000.0);
	else
	MaxProjectionInPhase=u_Projections;


	#ifdef BUILD_PLATFORM_LINUX //pierre

		struct tm when;
		time_t now;
		time(&now);
		when=*localtime(&now);

		char ptFilename[255]={0};
		char sDateTime[255]={0};

		sprintf(sDateTime,"%.4d%.2d%.2dT%.2d%.2d%.2d",when.tm_year+1900,when.tm_mon+1,when.tm_mday,when.tm_hour,when.tm_min,when.tm_sec);
		sprintf(ptFilename,"FM_MP2RAGEPMUsignal_%s",sDateTime);
		m_PMU.startLoggingSignal(SEQ::SIGNAL_EKG,ptFilename);

		if (m_FirstSignal!=1){	
		RTController::getInstance().setRealtimeProcessing(true);
		/// Calculate one kernel call ahead
		RTController::getInstance().setRealtimeProcessingMargin(  1.e-6*m_lTRMin);
		}
	#endif


	if (u_bDoCalibration)
	{

		if (!m_SBBCALIB.run(rMrProt, rSeqLim, rSeqExpo, &m_asSLC[0]))
		return SEQU_ERROR ;
	}

	//. --------------------------------------------------------------------------
	//. Set the frequency/phase properties of the RF pulses
	//. --------------------------------------------------------------------------
	m_sSRFzSet.set("sSRF01zSet", 0, m_sSRF.getInitialPhase());
	m_sSRFzNeg.set("sSRF01zSet", 0, -m_sSRF.getInitialPhase());

	//. --------------------------------------------------------------------------
	//. Set the frequency/phase properties of the adc OFFcenter is dealt in gadgetron
	//. --------------------------------------------------------------------------
	m_sADCzSet.set("sADC01zSet", 0, m_sSRF.getInitialPhase());
	m_sADCzNeg.set("sADC01zNeg", 0, -m_sSRF.getInitialPhase());

	m_sADCsgSet.set("sADC01sgSet", 0, m_sSRF.getInitialPhase());
	m_sADCsgNeg.set("sADC01sgNeg", 0, -m_sSRF.getInitialPhase());

	//. ---------------------------------------------------------------------------
	//. Dummy scan
	//. ---------------------------------------------------------------------------
	if(u_dummyScan)
		for(unsigned int j=0; j<3000;j++)
	       lStatus=runKernel( rMrProt, rSeqLim, rSeqExpo, KERNEL_PREPARE, 0,0,0);  

	//. ---------------------------------------------------------------------------
	//. Measurements
	//. ---------------------------------------------------------------------------
	for ( lChronologicSlice = 0; lChronologicSlice <= m_lSlicesToMeasure-1 ; lChronologicSlice++)
	{
		for ( lRepetition = 0; lRepetition <= m_lRepetitionsToMeasure ; lRepetition++) 
		{

			
				m_sADC[0].getMDH().setCrep(lRepetition);  // what's the current repetition?
				m_sSgADC[0].getMDH().setCrep(lRepetition);
			

			//. ---------------------------------------------------------------------------
			//. LOOP OVER PHASES
			//. ---------------------------------------------------------------------------
			while( CurrentProjection<u_Projections){

					//Here comes the physiological triggering 					
					if ( m_FirstMethod == SEQ::METHOD_TRIGGERING ) 
					{
						OnErrorPrintAndReturn( lStatus = fSBBECGFillTimeRun (&m_sTriggerBit1, m_lTrigHaltDuration1 ),"fSBBECGFillTimeRun");
						if ( m_SecondMethod == SEQ::METHOD_TRIGGERING ) 
						{
							OnErrorPrintAndReturn( lStatus = fSBBECGFillTimeRun (&m_sTriggerBit2, m_lTrigHaltDuration2),"fSBBECGFillTimeRun");
						}			
					}



				//. ---------------------------------------------------------------------------
				//. LOOP OVER PHASES
				//. ---------------------------------------------------------------------------
				for ( lPhase=0; lPhase< m_lPhasesToMeasure;lPhase++) {

					if( div (long(u_Projections-CurrentProjection),long(MaxProjectionInPhase)).quot>=1 )
					ProjectionToMeasure=MaxProjectionInPhase;
					else
					ProjectionToMeasure=u_Projections-CurrentProjection;
					
					for (int o = 0; o <repetitions; o++){
						for(int t = 0; t < 2; t++){
							if(t==0){
								//m_IRns.IRrun(rMrProt, rSeqLim, rSeqExpo, &m_asSLC[lChronologicSlice]);
								// ajout inversion pulse
								if(!m_IRns.IRrun(rMrProt, rSeqLim, rSeqExpo, &m_asSLC[lChronologicSlice])) // lancement de l'inversion
								{
									TRACE_PUT1_NLS(TC_INFO, TF_SEQ, "%s: m_IRns.run failed.",ptModule,m_IRns.getNLSStatus());
									return m_IRns.getNLSStatus();
								}

								fSBBFillTimeRun(m_dDelayTI1);
							}
							else
								fSBBFillTimeRun(m_dDelayTI2);

							/*for( int k=CurrentProjection; k < int(CurrentProjection+ProjectionToMeasure);k++){*/
							for( int k=0; k < u_lETL;k++){


							    
								m_sADC[0].setRelevantForMeasTime();
								m_sADC[0].getMDH().setCphs (lPhase);
								m_sSgADC[0].getMDH().setEvalInfoMask (m_sSgADC[0].getMDH().getEvalInfoMask() | MDH_ONLINE) ;
								m_sSgADC[0].getMDH().setEvalInfoMask (m_sSgADC[0].getMDH().getEvalInfoMask() | MDH_PATREFSCAN) ;

							

								m_sSgADC[0].getMDH().setPATRefScan(true);

								// run FM_MP2RAGE kernel	
								mSEQTest (rMrProt, rSeqLim, rSeqExpo, RTEB_ClockInitTR   , 1, 1, m_asSLC[0].getSliceIndex(), 0, 0) ;
								lStatus=runKernel( rMrProt, rSeqLim, rSeqExpo, KERNEL_IMAGE, o*u_lETL + k,lChronologicSlice,lPartition);
								mSEQTest (rMrProt, rSeqLim, rSeqExpo, RTEB_ClockCheck   , 1, 2, m_asSLC[0].getSliceIndex(), 0, 0) ;


							}
							if (t == 1)
								fSBBFillTimeRun(m_dDelayTR);
						}
					}

				}			
				CurrentProjection+=ProjectionToMeasure;

				// Always play dummy scan for cine
				lDumcount=0;
				if (m_FirstSignal!=1){	
				do{
					lDumcount++;
					lStatus=runKernel( rMrProt, rSeqLim, rSeqExpo, KERNEL_PREPARE, 0,lChronologicSlice,lPartition);  

				}
				while(bTrigTest && (lDumcount <4000));
				}
			}
			//Reset CurrentProjection projection of next repetition
			CurrentProjection=0;
			lStatus = fSBBMeasRepetDelaysRun ( rMrProt, rSeqLim, rSeqExpo, lRepetition );         // Send SyncEvents between Measurement repeats
		    OnErrorPrintAndReturn(lStatus,"fSBBMeasRepetDelaysRun");
		}
	}

	#ifdef BUILD_PLATFORM_LINUX
	m_PMU.stopLoggingSignal(SEQ::SIGNAL_EKG);
	#endif

	// Tell sequence unit test that sequence run is finished.
	mSEQTest(rMrProt,rSeqLim,rSeqExpo,RTEB_ORIGIN_fSEQRunFinish,0,0,0,0,0); /*! EGA-All !*/ 
	mPrintTrace1 (DEBUG_RUN, DEBUG_CALL | DEBUG_RETURN, "() <%s> finished", rSeqLim.getLinkedSeqFilename() ) ;
	return(lStatus);
}



//   --------------------------------------------------------------------------
//
//   Name        : FM_MP2RAGE::runKernel
//
//   Description :
///                 Executes the basic timing of the real-time sequence.
//
//   Return      :  NLS status
//
//   --------------------------------------------------------------------------
NLS_STATUS FM_MP2RAGE::runKernel(MrProt &rMrProt,SeqLim &rSeqLim, SeqExpo &rSeqExpo, long lKernelMode, long ProjectionNumber,long lChronologicSlice, long lpartition )
{
	//. --------------------------------------------------------------------------
	//. Local variables
	//. --------------------------------------------------------------------------
	static const char *ptModule         = {"fSEQRunKernel"} ; // point to name of current module
	NLS_STATUS         lStatus          = SEQU__NORMAL ;      // a status variable
	unsigned long      ulTestIdent      = 0 ;                 // tell unit test whether we're running or checking the kernel
	long               lT               = 0 ;                 // used as clock time in the main event block

	if (lKernelMode == KERNEL_CHECK) ulTestIdent = RTEB_ORIGIN_fSEQCheck;
	else                             ulTestIdent = RTEB_ORIGIN_fSEQRunKernel;


	//. --------------------------------------------------------------------------
	//. Set gradient amplitudes
	//. --------------------------------------------------------------------------
	if(lKernelMode!=KERNEL_PREPARE){
		m_sGradRead.setAmplitude(Gradx[ProjectionNumber]);
		m_sGradPhase.setAmplitude(Grady[ProjectionNumber]);
		m_sGradSlice.setAmplitude(Gradz[ProjectionNumber]);

		m_sGradReadDephFM.setAmplitude(-GradxDeph[ProjectionNumber]);
		m_sGradPhaseDephFM.setAmplitude(-GradyDeph[ProjectionNumber]);
		m_sGradSliceDephFM.setAmplitude(-GradzDeph[ProjectionNumber]);

		//m_sGradReadRephFM.setAmplitude(-GradxDeph[ProjectionNumber]);
		m_sGradReadRephFM.prepSymmetricTOTShortestTime(readMoment + m_sGradReadDephFM.getMomentumTOT());
		m_sGradPhaseRephFM.setAmplitude(-GradyDeph[ProjectionNumber]);
		m_sGradSliceRephFM.setAmplitude(-GradzDeph[ProjectionNumber]);

		 if(u_Mode==2 ){
			m_sGradReadDephFM.setAmplitude(-GradxDeph[ProjectionNumber]);
			m_sGradPhaseDephFM.setAmplitude(-GradyDeph[ProjectionNumber]);
			m_sGradSliceDephFM.setAmplitude(-GradzDeph[ProjectionNumber]);
			m_sGradReadRephFM.setAmplitude(-GradxDeph[ProjectionNumber]);
			m_sGradPhaseRephFM.setAmplitude(-GradyDeph[ProjectionNumber]);
			m_sGradSliceRephFM.setAmplitude(-GradzDeph[ProjectionNumber]);
		}
	}
	 else{	
		m_sGradRead.setAmplitude (0);
		m_sGradPhase.setAmplitude(0);
		m_sGradSlice.setAmplitude(0);

			// FMUTE
			m_sGradReadDephFM.setAmplitude(0);
			m_sGradPhaseDephFM.setAmplitude(0);
			m_sGradSliceDephFM.setAmplitude(0);
			m_sGradReadRephFM.setAmplitude(0);
			m_sGradPhaseRephFM.setAmplitude(0);
			m_sGradSliceRephFM.setAmplitude(0);


		 if( u_Mode==2 ){
			m_sGradReadDephFM.setAmplitude(0);
			m_sGradPhaseDephFM.setAmplitude(0);
			m_sGradSliceDephFM.setAmplitude(0);
			m_sGradReadRephFM.setAmplitude(0);
			m_sGradPhaseRephFM.setAmplitude(0);
			m_sGradSliceRephFM.setAmplitude(0);	
		 }
	 }

	#ifdef BUILD_PLATFORM_LINUX	
	if (m_FirstSignal!=1){
		lPhysiolTime=m_PMU.getTimeStamp(SEQ::SIGNAL_EKG);
		lPhysCount++;
		bTrigTest=((lPhysiolTime*2500.)> m_lTRMin);	
	}	
    #endif

	//. --------------------------------------------------------------------------
	//. Set the  getMDH() parameters
	//. --------------------------------------------------------------------------
	
		m_sADC[0].getMDH().setCeco(0);
		m_sADC[0].getMDH().setCseg(0);
		m_sADC[0].getMDH().setCslc (0); // what's the current slice?
		m_sADC[0].getMDH().setCpar (0); // what's the current partition?
		m_sADC[0].getMDH().setRawDataCorrection(0);
		m_sADC[0].getMDH().setClin            ((unsigned short) ProjectionNumber);  
		//m_sADC[i].getMDH().setFirstScanInSlice( ProjectionNumber == 0 );
		if (l_offset>0)
			m_sADC[0].getMDH().setCset(1);
		else
			m_sADC[0].getMDH().setCset(0);
		m_sADC[0].getMDH().addToEvalInfoMask(MDH_ONLINE);   
		
		//m_sADC[i].getMDH().setEvalInfoMask (m_sADC[i].getMDH().getEvalInfoMask() | MDH_ONLINE) ;

		if (l_offset>0)
		{
			m_sSgADC[0].getMDH().setCeco(0);
			m_sSgADC[0].getMDH().setCseg(0);
			m_sSgADC[0].getMDH().setCslc (0); // what's the current slice?
			m_sSgADC[0].getMDH().setCpar (0); // what's the current partition?
			m_sSgADC[0].getMDH().setRawDataCorrection(0);
			//m_sSgADC[i].getMDH().setEvalInfoMask (m_sSgADC[i].getMDH().getEvalInfoMask() | MDH_ONLINE) ;
			m_sSgADC[0].getMDH().setClin            (0);  
			m_sSgADC[0].getMDH().setFirstScanInSlice( ProjectionNumber == 0 );
			m_sSgADC[0].getMDH().setCset(0);
		}
	//////////////////////////////////////////////////

	if (rMrProt.fastImaging().getulEnableRFSpoiling()  && u_Mode!=2)  { 
		//. ---------------------------------------------------------------------------
		//. Handle RF spoiling in GRE
		//. ---------------------------------------------------------------------------
		m_dRFSpoilIncrement += RFSPOIL_INCREMENTdeg ; //RFSPOIL_INCREMENTdeg=50Â°
		m_dRFSpoilPhase     += m_dRFSpoilIncrement ;
		m_dRFSpoilPhase     = fmod(m_dRFSpoilPhase,     (double) RFMAXPHASEdeg);            // keep phase smaller than 1000 * 2*Pi
		m_dRFSpoilIncrement = fmod(m_dRFSpoilIncrement, (double) RFMAXPHASEdeg);
		m_sADCzSet.increasePhase(m_dRFSpoilPhase);
		m_sADCzNeg.decreasePhase(m_dRFSpoilPhase);
		m_sADCsgSet.increasePhase(m_dRFSpoilPhase);
		m_sADCsgNeg.decreasePhase(m_dRFSpoilPhase);
		m_sSRFzSet.increasePhase(m_dRFSpoilPhase);
		m_sSRFzNeg.decreasePhase(m_dRFSpoilPhase);		
	}

	if(u_Mode==2){
		//. --------------------------------------------------------------------------
		//. 180 phase loop if TRUEFISP
		//. --------------------------------------------------------------------------
		m_sSRFzSet.increasePhase (180) ;    /*! EGA-05 !*/
		m_sSRFzNeg.decreasePhase (180) ;    /*! EGA-05 !*/

		m_sADCzSet.increasePhase (180) ;    /*! EGA-05 !*/
		m_sADCzNeg.decreasePhase (180 ) ;    /*! EGA-05 !*/


		while (m_sSRFzSet.getPhase() > (double)RFMAXPHASEdeg )
		{
			m_sSRFzSet.increasePhase(-RFMAXPHASEdeg);
			m_sSRFzNeg.decreasePhase(+RFMAXPHASEdeg);
			m_sADCzSet.increasePhase (-RFMAXPHASEdeg);   
			m_sADCzNeg.decreasePhase (+RFMAXPHASEdeg);  
		}
	}	

	//. ---------------------------------------------------------------------------
	//. Begin of event block
	//. ---------------------------------------------------------------------------

	fRTEBInit(m_asSLC[lChronologicSlice].getROT_MATRIX());    /* EGA-07 */
	 lT=100;

	//- ***************************************************** S E Q U E N C E   T I M I N G *************************
	//- *           Start Time    |    NCO    |  SRF  |  ADC  |             Gradient Events             | Sync
	//- *             (usec)      |   Event   | Event | Event |     phase    |   read     |    slice    | Event
	//- *fRTEI(                   ,           ,       ,       ,              ,            ,             ,         );
	//- *************************************************************************************************************

	 //-----------------------------------------Slice Selection/Excitation--------------------------------------------
	 fRTEI(lT                       ,&m_sSRFzSet, &m_sSRF,      0,             0,            0,            0,        0);
	 fRTEI(lT + m_sSRF.getDuration(),&m_sSRFzNeg,       0,      0,             0,            0,            0,        0);

	 //----------------------------------------------Sampling---------------------------------------------------------
	 lT += m_sSRF.getDuration() + MinDurationBetweenRFandADC + m_alTEFil[0];	

	 if(l_offset>0){
		fRTEI(lT                              ,&m_sADCsgSet  ,        0, &m_sSgADC[0]  ,             0,            0,             0,    0);
		lT += fSDSRoundUpGRT(l_offset*(m_sADC[0].getDwellTime())/(1000));
		fRTEI(lT                              ,&m_sADCsgNeg  ,        0, 0  ,             0,            0,             0,    0);
	 }

	 fRTEI(lT   ,            0,        0,         0, &m_sGradPhaseDephFM  , &m_sGradReadDephFM  ,&m_sGradSliceDephFM   ,    0);
	 fRTEI(lT  + m_sGradSliceDephFM.getTotalTime(),            0,        0,         0, &m_sGradPhase  , &m_sGradRead  ,&m_sGradSlice   ,    0);


	 if(lKernelMode!=KERNEL_PREPARE){
		lT += m_sGradRead.getRampUpTime() + m_sGradReadDephFM.getTotalTime();
		fRTEI(lT + (m_sGradRead.getFlatTopTime() - m_sADC[0].getDuration())/2                                ,    &m_sADCzSet  ,        0,   &m_sADC[0],             0,            0,             0,    0);
		fRTEI(lT + (m_sGradRead.getFlatTopTime() - m_sADC[0].getDuration())/2 +m_sADC[0].getRoundedDuration(),    &m_sADCzNeg  ,        0,            0,             0,            0,             0,    0);
	 }
	 else{
		fRTEI(lT                              ,0  ,        0, 0  ,             0,            0,             0,    0);
		fRTEI(lT + m_sADC[0].getRoundedDuration(),0  ,        0,         0,             0,            0,             0,    0);
	 }

	lT +=   m_sGradPhase.getDuration() ;

	 //----------------------------------------------Spoiler & Finish-----------------------------------------------------------
	 if(u_Mode==1){

		fRTEI(lT                              ,            0,        0,         0, &m_sGradPhaseRephFM  , &m_sGradReadRephFM  ,&m_sGradSliceRephFM   ,    0);
		lT += m_sGradReadRephFM.getTotalTime(); 
		fRTEI(lT,      0 ,       0,        0,         &m_sGSpoil,     &m_sGSpoil,           &m_sGSpoil,     0    );
		lT +=  m_sGSpoil.getTotalTime();

	 }
	 else if (u_Mode==2){
		 fRTEI(lT                          ,            0,        0,         0, &m_sGradPhaseDeph  , &m_sGradReadDeph  ,&m_sGradSliceDeph   ,    0);
		 lT += m_sGradReadDeph.getTotalTime();
	 }


	fRTEI(rMrProt.tr()[0],     0,        0,        0,         0,            0,             0,        0);
	mSEQTest (rMrProt, rSeqLim, rSeqExpo, ulTestIdent    , 10, ProjectionNumber, m_asSLC[0].getSliceIndex(), 0, 0) ;

	OnErrorPrintAndReturn(lStatus = fRTEBFinish(),"fRTEBFinish [*0100*]");

	//. ---------------------------------------------------------------------------
	//. End of event block
	//. ---------------------------------------------------------------------------
	return(lStatus);	

}


// * -------------------------------------------------------------------------- *
// *                                                                            *
// * Name        :  FM_MP2RAGE::createUI                                         *
// *                                                                            *
// * Description :  Instantiation of UI classes                                 *
// *                                                                            *
// * Return      :  NLS status                                                  *
// *                                                                            *
// * -------------------------------------------------------------------------- *



NLS_STATUS FM_MP2RAGE::createUI (SeqLim&)
{

	static const char *ptModule = {"ute::createUI"};

	#ifdef WIN32

	//  ----------------------------------------------------------------------
	//  Delete existing instance if necessary
	//  ----------------------------------------------------------------------
	if ( m_pUI )  {
		delete m_pUI;
		m_pUI = NULL;
	}



	//  ----------------------------------------------------------------------
	//  Instantiation of the UI class
	//  ----------------------------------------------------------------------
	try  {
		m_pUI = new FM_MP2RAGEUI();
	}

	catch (...)  {
		delete m_pUI;
		m_pUI = NULL;

		TRACE_PUT1(TC_ALWAYS, TF_SEQ,"%s: Cannot instantiate UI class !", ptModule);
		return ( SEQU_ERROR );
	}

	#endif

	return ( SEQU_NORMAL );

}   // end:FM_MP2RAGE::createUI



const FM_MP2RAGEUI* FM_MP2RAGE::getUI (void) const
{
	return ( m_pUI );
}



long   FM_MP2RAGE::getKernelRequestsPerMeasurement(void)
{
	return (m_lKernelRequestsPerMeasurement);

}


long   FM_MP2RAGE::getKernelCallsPerRelevantSignal(void)
{
	return (m_lKernelCallsPerRelevantSignal);

}

long   FM_MP2RAGE::getDurationMainEventBlock(void)
{
	return (m_lDurationMainEventBlock);

}

long   FM_MP2RAGE::getScanTimeAllSats(void)
{
	return (m_lScanTimeAllSats);

}

double FM_MP2RAGE::getdMinRiseTime(void)
{
	return (m_dMinRiseTime);

}

double FM_MP2RAGE::getdGradMaxAmpl(void)
{
	return (m_dGradMaxAmpl);
}


/*---------------------------------------------------------------------------*/
/*  Copyright (C) Siemens AG 1998  All Rights Reserved.  Confidential        */
/*---------------------------------------------------------------------------*/