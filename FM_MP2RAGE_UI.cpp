
//    -----------------------------------------------------------------------------
//      Copyright (C) Siemens AG 1998  All Rights Reserved.
//    -----------------------------------------------------------------------------
//
//     Project: NUMARIS/4
//        File: \n4_servers1\pkg\MrServers\MrImaging\seq\fm_radial\fm_radial_UI.cpp
//     Version:
//      Author: Clinical
//        Date: n.a.
//
//        Lang: C++
//
//     Remarks: This is the demo sequence fm_radialUI.
//              DO NOT base any diagnosis on images generated by this sequence.
//
//  ***************************************************************************/

// --------------------------------------------------------------------------
// General Includes
// --------------------------------------------------------------------------
#include "MrServers/MrMeasSrv/SeqIF/Sequence/Sequence.h"
#ifdef WIN32
    #include "MrServers/MrProtSrv/MrProtocol/UILink/MrStdNameTags.h"
#endif






//  --------------------------------------------------------------------------
//  Application includes
//  --------------------------------------------------------------------------
#include "MrServers/MrImaging/seq/fm_radial/fm_radial.h"
#include "MrServers/MrImaging/seq/fm_radial/fm_radial_UI.h"



#ifndef SEQ_NAMESPACE
    #error SEQ_NAMESPACE not defined
#endif
using namespace SEQ_NAMESPACE;



#ifdef WIN32





    //  ----------------------------------------------------------------------
    //
    //  Name        :  getSeq
    //
    //  Description :
    /// \brief         Returns the pointer to the sequence flash
    //
    //  Return      :  fm_radialUI*
    //
    //  ----------------------------------------------------------------------
    fm_radial* getSeq (MrUILinkBase* const pThis)
    {
        return ( static_cast<fm_radial*>(pThis->sequence().getSeq()) );
    }




    //  ----------------------------------------------------------------------
    //
    //  Name        :  getUI
    //
    //  Description :
    /// \brief         Returns the pointer to the UI class of the flash
    ///                 sequence
    //
    //  Return      :  fm_radialUI*
    //
    //  ----------------------------------------------------------------------
    const fm_radialUI* getUI (MrUILinkBase* const pThis)
    {
        return ( static_cast<fm_radial*>(pThis->sequence().getSeq())->getUI() );
    }




    //  --------------------------------------------------------------------------
    //  --------------------------------------------------------------------------
    //
    //                         Definition of solve handler
    //
    //  --------------------------------------------------------------------------
    //  --------------------------------------------------------------------------


   //+ [ Function ***************************************************************
   //+
   //+  Name        : fSSolveSelectionConflict
   //+
   //+  Description : Solve handler for  UI Conflicts of type Selection
   //+                    (solves with TeTrTi)
   //+  Return      :
   //+
   //+ **************************************************************************
    // In this module we solve the conflict of switching Fat suppression on while the
    //  TR is too little. The method  fUICSolveSelectionConflict  tries to solve this
    //  problem by tyring different values for TE, TR and TI.

    unsigned fSSolveSelectionConflict
        (
        LINK_SELECTION_TYPE*  const pThis,           // ...
        char**                      arg_list,       // receives confirmation message
        const void*                 pAddMem,        // for internal use
        const MrProtocolData::MrProtData*               pOrigProt,      // Original protocol with old fat suppression mode
        long                        lIndex          // Array index reserved
        )
    {
        return ( fUICSolveSelectionConflict ( pThis, arg_list, pAddMem, pOrigProt, lIndex, NULL, NULL, NULL ) );
    }



    //+  [ Function **************************************************************
    //+
    //+  Name        : fDSolveDoubleConflict
    //+
    //+  Description : Solve handler for  UI Conflicts of type double
    //+                    (solves with TeTrTi)
    //+  Return      :
    //+
    //+ **************************************************************************
    // With this module we solve the conflict of decreasing the bandwidth while
    //  TR is too little. The method  fUICSolveDoubleParamConflict  tries to solve this
    //  problem by tyring different values for TE, TR and TI.
    unsigned fDSolveDoubleConflict
        (
        LINK_DOUBLE_TYPE* const pThis,
        char**                  arg_list,  // receives confirmation message
        const void*             pAddMem,   // for internal use
        const MrProtocolData::MrProtData*           pOrigProt, // Original protocol with old bandwidth
        long                    lIndex     // Array index reserved
        )
    {
        return ( fUICSolveDoubleParamConflict ( pThis, arg_list, pAddMem, pOrigProt, lIndex, NULL, NULL, NULL ) );
    }


    //+ [ Function ****************************************************************
    //+
    //+  Name        : fBSolveFunnyModeConflict1
    //+
    //+  Description : Solve handler for demonstration of a self-written solve-handler
    //+
    //+                For some unknown reason, we do not like to have triggering and
    //+                 the TokTokTok on at the same time.
    //+                To manage this home-made conflict, we turn off triggering if the
    //+                 user selects "Introduction".
    //+                Note: To handle the other way (turn off Introduction when selecting
    //+                 triggering) one would have to write another function
    //+
    //+  Return      : 0              if no solution possible
    //+                MRI_STD_STRING on success. The text in arg_list is then used
    //+                                to format the confirmation message.
    //+ ***************************************************************************
    unsigned fBSolveFunnyModeConflict1
        (
        LINK_BOOL_TYPE* const pThis,   // ...
        char*                arg_list[],      // receives confirmation message
        const void*           /* pToAddMemory */,
        const MrProtocolData::MrProtData* /*pOrigProt*/, // Original protocol with Intro = OFF
        long                  /* lIndex  */  // Array index reserved
        )
    {

        static  const char tConfirmationText[] = "$&OK$&Undo$$Switching Introduction ON has disabled triggering";
        MrProt rNewProt (pThis->prot());     // new protocol with Intro = ON
        // const SeqLim*         pSeqLim    = &pThis->seqLimits();
        SEQ::PhysioSignal FirstSignal ;
        SEQ::PhysioMethod FirstMethod ;
        SEQ::PhysioSignal SecondSignal ;
        SEQ::PhysioMethod SecondMethod ;
        // Can we solve this problem?
        rNewProt.physiology().getPhysioMode (FirstSignal, FirstMethod, SecondSignal, SecondMethod);
        if ( (rNewProt.intro() ) &&
            (FirstMethod == SEQ::METHOD_TRIGGERING) )
        {
            // Solve it, disable triggering
            rNewProt.physiology().setPhysioMode(SEQ::SIGNAL_NONE, SEQ::METHOD_NONE, SecondSignal, SecondMethod);
            // Set the user dialog text (if arg_list exists)
            if(arg_list) arg_list[0] = (char*) tConfirmationText;
            return MRI_STD_STRING;
        }
        //  we can't solve the problem
        return 0;
    }

    //+ [ Function ****************************************************************
    //+
    //+  Name        : fBSolveFunnyModeConflict2
    //+
    //+  Description : Solve handler for demonstration of a self-written solve-handler
    //+                If we hadn't written this 2nd solve handler, only the conflict
    //+                 when trying to turn intro() on would be solved.
    //+                This handler takes care of the SELECTION-type Trigger-Mode-switch
    //+
    //+  Return      : 0              if no solution possible
    //+                MRI_STD_STRING on success. The text in arg_list is then used
    //+                                to format the confirmation message.
    //+ ***************************************************************************

    unsigned fBSolveFunnyModeConflict2
        (
        LINK_SELECTION_TYPE* const pThis,   // ...
        char*                      arg_list[],      // receives confirmation message
        const void*                /* pToAddMemory */,
        const MrProtocolData::MrProtData* /*pOrigProt*/,     // Original protocol with Intro = OFF
        long                       /* lIndex    */      // Array index reserved
        )
    {

        static  const char tConfirmationText[] = "$&OK$&Undo$$Switching triggering on will turn off Introduction";
        MrProt rNewProt (pThis->prot());     // new protocol with Trigger = ON
        // const SeqLim*         pSeqLim    = &pThis->seqLimits();
        SEQ::PhysioSignal FirstSignal ;
        SEQ::PhysioMethod FirstMethod ;
        SEQ::PhysioSignal SecondSignal ;
        SEQ::PhysioMethod SecondMethod ;
        // Can we solve this problem?
        rNewProt.physiology().getPhysioMode (FirstSignal, FirstMethod, SecondSignal, SecondMethod);
        if ( (rNewProt.intro() ) &&
            (FirstMethod == SEQ::METHOD_TRIGGERING) )
        {
            // Solve it, disable TokTokTok
            rNewProt.intro(false);
            // Set the user dialog text (if arg_list exists)
            if(arg_list) arg_list[0] = (char*) tConfirmationText;
            return MRI_STD_STRING;
        }
        //  we can't solve the problem
        return 0;
    }








#endif


    ///  \brief Constructor
    ///
    fm_radialUI::fm_radialUI(){}


    ///  \brief Destructor
    ///
    fm_radialUI::~fm_radialUI(){}




    //  --------------------------------------------------------------------------
    //
    //  Name        : registerUI
    //
    //  Description :
    /// \brief        This method registers all given set / get / Solve - handlers
    ///
    ///               It can be executed on the measuement system, too, but is empty there.
    ///
    ///
    ///               It returns an NLS status
    ///
    //  Return      : long
    //
    //  --------------------------------------------------------------------------

    NLS_STATUS fm_radialUI::registerUI (SeqLim &rSeqLim)
    {

        static const char * const ptModule = {"fm_radialUI::registerUI"};

        char tMrTag[64];

#ifdef WIN32

          fStdImagingInitPost (rSeqLim);

            // ----------------------------------------------------------------------------------
            // Registration of set handler methods
            //
            //                                           parameter tag     new handler function
            // ----------------------------------------------------------------------------------




            // ----------------------------------------------------------------------------------
            // Registration of solve handler methods
            //
            //                                        parameter tag         new handler function
            // ----------------------------------------------------------------------------------
        //char tMrTag[sizeof(MR_TAG_BANDWIDTH)+3];
        sprintf (tMrTag, "%s.0\0", MR_TAG_BANDWIDTH );
        m_bandwidth.registerSolveHandler   (rSeqLim, tMrTag                  ,         fDSolveDoubleConflict    );
        m_fatSuppres.registerSolveHandler (rSeqLim, MR_TAG_FAT_SUPPRESSION   ,         fSSolveSelectionConflict );
        m_TriggerTok.registerSolveHandler (rSeqLim, MR_TAG_INTRO             ,         fBSolveFunnyModeConflict1);
        m_TokTrigger.registerSolveHandler (rSeqLim, MR_TAG_FIRST_SIGNAL_MODE ,         fBSolveFunnyModeConflict2);

      

        // file containing the default postprocessing protocol (EVAProtocol)
        //  The corresponding card in the UI is activated via setApplicationCard() in fSEQPrep

        rSeqLim.setDefaultEVAProt (_T("%SiemensEvaDefProt%\\Inline\\Inline.evp"));

#endif

        return ( SEQU__NORMAL );

    }





