//    -----------------------------------------------------------------------------
//      Copyright (C) Siemens AG 1998  All Rights Reserved.
//    -----------------------------------------------------------------------------
//
//     Project: NUMARIS/4
//        File: \n4_servers1\pkg\MrServers\MrImaging\seq\FM_MP2RAGE\FM_MP2RAGE.h
//     Version: \main\9
//      Author: Clinical
//        Date: 2011-09-07 11:42:33 +02:00
//
//        Lang: C++
//
//     Descrip: Deklarations for FM_MP2RAGE.cpp
//
//
/// \brief  File containing declarations for the sequences
///         - FM_MP2RAGE
///         - Flash1
///
/// This file contains the declaration of the class FM_MP2RAGE.
/// The sequence FM_MP2RAGE and Flash1 use it to generate very nice images.
///
///     Remarks: This is the demo sequence FM_MP2RAGE.
///              DO NOT base any diagnosis on images generated by this sequence.
///
//  ***************************************************************************/
///



#ifndef FLASH_BACK_h
#define FLASH_BACK_h 1


//  --------------------------------------------------------------------------
//  General Includes
//  --------------------------------------------------------------------------
#include "MrServers/MrImaging/libSBB/StdSeqIF.h"
#include "MrServers/MrMeasSrv/MeasUtils/nlsmac.h"       // * definition of type NLS_STATUS  *
#include "ProtBasic/Interfaces/MrWipMemBlock.h"

//  --------------------------------------------------------------------------
//  Application includes
//  --------------------------------------------------------------------------

#include "MrServers/MrImaging/libSBB/SBBTSat.h"
#include "MrServers/MrImaging/seq/SystemProperties.h"        // Siemens system properties
#include "MrServers/MrImaging/libSeqSysProp/SysProperties.h"

#include  "MrServers/MrImaging/libSBB/SEQLoop.h"          // class SeqLoop

#include "SBBCALIB.h"

#include "MrServers/MrImaging/libKSpace/SamplingParams.h" //trajectory


#ifdef WIN32    // VXWORKS is only defined for the MARS. In that case, no Solve handlers are needed.
#include "MrServers/MrProtSrv/MrProtocol/UILink/MrStdNameTags.h"
#include "MrServers/MrProtSrv/MrProtocol/libUILink/UILinkLimited.h"
#include "MrServers/MrProtSrv/MrProtocol/libUILink/UILinkSelection.h"
#include "MrServers/MrProtSrv/MrProtocol/libUILink/UILinkArray.h"
#include "MrServers/MrProtSrv/MrProtocol/UILink/StdProtRes/StdProtRes.h"
#include "MrServers/MrProtSrv/MrProtocol/libUICtrl/UICtrl.h"
#include "MrServers/MrMeasSrv/SeqIF/Sequence/Sequence.h" // Definition of class Sequence
#include <vector>
#endif

// ....



#ifdef BUILD_SEQU
#define __OWNER
#endif
#include "MrCommon/MrGlobalDefinitions/ImpExpCtrl.h"


//. ----------------------------------------------------------
//. Instantiate Sequence Building Blocks (SBBs)
//. ----------------------------------------------------------
#define MAXRSATS 8
// Maximum number of allowed RSats: limited by the user interface
// given in the define K_NO_SAT_MAX in "MrServers/MrProtSrv/MrProt/prot.h"

// Instantiation of most Proxies not necessary since VB13A; relevant information is available via SysProperties

// Hints for debugging:
//   Avoid printf-statements (or cout-streams) because they are slow.
//   Use TRACE_PUT-macros instead.
//     The output will appear in the File c:\MedCom\Log\MrMeas_container.log (and MrUIBackends_container.log)
//-        TRACE_PUT1(TC_ALWAYS, TF_SEQ, "%s: initialized WIP Parameters.\n",ptModule);
//-                 ^        ^     ^                     ^                     ^
//             #parameters  when  cause                Text                parameter
//
//   Additionally, you can view the output using "MrTraceViewer(d).exe"
//
//   The TRACE_PUT macro writes also data to a log on the MARS, this log can be viewed
//    by entering "mstart mpcutracelogger" on the MRC host.
//
//-        mPrintTrace2 (DEBUG_RUN, DEBUG_CALL, "(slice=%ld, line=%ld) ", asSLC[lChronologicSlice].getSliceIndex(), lLine  ) ;
//
//   is an alternative method (calls also TRACE_PUT) but the names (DEBUG_CALL) correspond to the
//      debug bits that can be set via the IDEA "mask" command.
//


// define some constants that make the code more readable:
//   The elements on the Sequence/Special card, sorted by type (first the "long", then the "double")
enum eSeqSpecialParameters {WIP_Selection_Box = 1, WIP_UpperCheckBox, WIP_LowerCheckBox, WIP_LongParameter, WIP_Double_Array_Elm1, WIP_Double_Array_Elm2, WIP_Double_Array_Elm3 };

// The states that the SELECTION box or the checkboxes can have, is stored as an enum, too. It starts with
//  1 to avoid a zero value indicating that the parameter was not yet initialized.
enum eSeqSpecialParameterValues {WIP_SelectionBoxValue0 = 1, WIP_SelectionBoxValue1, WIP_SelectionBoxValue2, WIP_CheckBoxOn, WIP_CheckBoxOff };

// To be able to access the double paramater values getsWiPMemBlock().getadFree()[] from index 0 on,
//  a variable is defined that contains the
//  value of the first parameter card containing double values
long const lWIP_IndexDoubleValues_Start = WIP_Double_Array_Elm1;


//  --------------------------------------------------------------------------
//  Forward declarations
//  --------------------------------------------------------------------------
namespace MrProtocolData
{
	class MrProtData;
}
class MrProt;
class SeqLim;
class SeqExpo;
class Sequence;




//  --------------------------------------------------------------------------
//
/// \brief <b> Class definition of FM_MP2RAGE. This class is used by the sequences
///         - FM_MP2RAGE
///         - Flash1    </b>
///
/// This file contains the declaration of the class FM_MP2RAGE.
/// The sequence FM_MP2RAGE and Flash1 use it to generate very nice images.
///
//  --------------------------------------------------------------------------

namespace SEQ_NAMESPACE
{

	class FM_MP2RAGEUI;

	/**
* @brief This class is used by the sequences
* - FM_MP2RAGE
* - Flash1
*/
	class FM_MP2RAGE : public StdSeqIF
	{

	public:
		/**
		* @brief Standard constructor of the FM_MP2RAGE sequence object. The class members are initialized
		* with default values.
		*/
		FM_MP2RAGE();



		/**
		* @brief Destructor of the FM_MP2RAGE sequence object. The FM_MP2RAGEUI object is destructed as well.
		*/
		virtual ~FM_MP2RAGE();



		//   --------------------------------------------------------------------------
		//
		//   Name        :  FM_MP2RAGE::initialize
		//
		//   Description :
		///  \brief        Initialization of the sequence
		///
		///                On the host, the object m_pUI will actually contain sensible
		///                  data after FM_MP2RAGE::initialize. On the measurement system, it
		///                  is basically an empty object behind it.
		///
		//   Return      :  NLS status
		//
		//   --------------------------------------------------------------------------
		virtual NLSStatus initialize (SeqLim &rSeqLim);



		//  --------------------------------------------------------------------------
		//
		//  Name        :  FM_MP2RAGE::prepare
		//
		//  Description :
		/// \brief <b>     Preparation of the sequence during binary search and prior
		///                 to sequence execution  </b>
		//
		//  Return      :  NLS status
		//
		//  --------------------------------------------------------------------------
		virtual NLSStatus prepare (MrProt &rMrProt, SeqLim &rSeqLim, SeqExpo &rSeqExpo);



		//  --------------------------------------------------------------------------
		//
		//  Name        :  FM_MP2RAGE::check
		//
		//  Description :
		/// \brief  <b>    Check of the sequence for gradient stimulation </b>
		///
		///                This method is called by the framework prior to a
		///                 measurement on the host to ensure, that
		///                 - no gradient overflow occurs
		///                 - the stimulation will not exceed the threshold
		///
		//  Return      :  NLS status
		//
		//  --------------------------------------------------------------------------
		virtual NLSStatus check (MrProt  &rMrProt, SeqLim &rSeqLim, SeqExpo &rSeqExpo, SEQCheckMode *  pSEQCheckMode);


		//  --------------------------------------------------------------------------
		//
		//  Name        :  FM_MP2RAGE::run
		//
		//  Description :
		///     \brief     Execution of the sequence
		//
		//  Return      :  NLS status
		//
		//  --------------------------------------------------------------------------
		virtual NLSStatus run (MrProt &rMrProt, SeqLim &rSeqLim, SeqExpo &rSeqExpo);



		//   --------------------------------------------------------------------------
		//
		//   Name        :  FM_MP2RAGE::runKernel
		//
		//   Description :
		///  \brief <b>     Executes the basic timing of the real-time sequence.   </b>
		///
		///                 The method runKernel plays out a sequlSlicesToMeasureence "Kernel",
		///                  consisting of one or more lines in k-Space.
		///                 It is called by SeqLoop.
		///
		//   Return      :  NLS status
		//
		//   --------------------------------------------------------------------------
		virtual NLS_STATUS runKernel(MrProt &rMrProt,SeqLim &rSeqLim, SeqExpo &rSeqExpo, long lKernelMode,long ProjectionNumber,long lChronologicSlice, long lpartition);





		//  --------------------------------------------------------------
		//
		//  Name        :  getUI
		//
		//  Description :
		/// \brief <b>     Returns the pointer to the FM_MP2RAGE UI class  </b>
		///
		///                This method is only sensible on the host.
		///                On the measurement system, it will return an nearly empty object.
		///
		//  Return      :  FM_MP2RAGEUI*
		//
		//  --------------------------------------------------------------
		const FM_MP2RAGEUI* getUI (void) const;




		//  ------------------------------------------------------------------
		//  Declare additional P U B L I C member functions, e.g. functions
		//  that will be accessed in UI handlers (outside the class).
		//  ------------------------------------------------------------------

		long   getKernelRequestsPerMeasurement(void);

		long   getKernelCallsPerRelevantSignal(void);

		long   getDurationMainEventBlock(void);

		long   getScanTimeAllSats(void);

		double getdMinRiseTime(void);

		double getdGradMaxAmpl(void);



	protected:



		//  ------------------------------------------------------------------
		///  No of phase encoding lines with iPAT
		///  CAUTION: This member is intended as an example and can be removed
		///  if not required for the actual sequence
		//  ------------------------------------------------------------------
		long       m_alTEFil[K_NO_TIME_ELEMENTS]               ;
		int32_t    m_lLinesToMeasure                           ;
		long       m_lRepetitionsToMeasure                     ;
		long       m_lPhasesToMeasure                          ;
		long       m_lContrastsToMeasure					   ;
		long       m_lSlicesToMeasure                          ;
		int32_t    m_lPartitionsToMeasure                      ;
		long       m_lScanTimeAllSats                          ;
		long       m_lDurationMainEventBlock                   ;
		long       m_lKernelRequestsPerMeasurement             ;
		long       m_lKernelCallsPerRelevantSignal             ;
		long       m_lInterDuration                            ;
		long       m_lTrigHaltDuration1                        ;
		long       m_lTrigHaltDuration2                        ;
		double     m_dRFSpoilIncrement                         ;
		double     m_dRFSpoilPhase                             ;
		long       m_lMySliSelRampTime                         ;
		double     m_dMinRiseTime                              ;
		double     m_dGradMaxAmpl                              ;
		double	   duration								       ;
		double     DephGradAmpl							       ;
	    long       m_lTRMin                                    ; // minimum TR
		long	   m_lTEMin									   ;
	    long 	   MinDurationBetweenADCandRF                  ;
	    long 	   MinDurationBetweenRFandADC                  ;
		long	   m_MP2Projections							   ;
		int		   repetitions								   ;
		int m_t;
		// Gradient Amplitude
		long m_dGradMaxAmplitude							   ;
		long GradientAmplitudeFOV							   ;
		long readMoment										   ;

		// Variables for Ramp Compensation
		long       m_lRCColumn								   ;
		//Variables for Refoc
		//bool m_lRefoc;
		long m_SBBTime;

	   // Variables for trigger mode
		SEQ::PhysioSignal m_FirstSignal                        ;
		SEQ::PhysioMethod m_FirstMethod                        ;
		SEQ::PhysioSignal m_SecondSignal                       ;
		SEQ::PhysioMethod m_SecondMethod                       ;

		// Slice position information (rotation matrices and shifts)
		sSLICE_POS m_asSLC[K_NO_SLI_MAX]                       ;
	  
			SBBList m_mySBBlist;
		//. ----------------------------------------------------------
		//. Instantiate RF Pulse objects
		//. ----------------------------------------------------------

		// every rf-pulse must (!) have an unique name
		//  (e.g. fl_Flash_ex = flash template excitation)"
		//  maximium of 12 chars
		sRF_PULSE_RECT           m_sSRF                   ;
		// define an event that sets the transmitter phase
		sFREQ_PHASE              m_sSRFzSet               ;
		// define an event that resets the transmitter phase
		sFREQ_PHASE              m_sSRFzNeg               ;

		sRF_PULSE_RECT           m_sSRF02                   ;
		// define an event that sets the transmitter phase
		sFREQ_PHASE              m_sSRF02zSet               ;
		// define an event that resets the transmitter phase
		sFREQ_PHASE              m_sSRF02zNeg               ;
		
		//. ----------------------------------------------------------
		//. Instantiate Gradient Pulse objects
		//. ----------------------------------------------------------
		sGRAD_PULSE m_sGradRead								;
		sGRAD_PULSE m_sGradSlice							;
		sGRAD_PULSE m_sGradPhase							;
		sGRAD_PULSE m_sGradReadDeph							;
		sGRAD_PULSE m_sGradPhaseDeph						;
		sGRAD_PULSE m_sGradSliceDeph						;
        sGRAD_PULSE m_sGSpoil								;

		//FMUTE
		sGRAD_PULSE m_sGradReadDephFM						;
		sGRAD_PULSE m_sGradPhaseDephFM						;
		sGRAD_PULSE m_sGradSliceDephFM						;
		sGRAD_PULSE m_sGradReadRephFM						;
		sGRAD_PULSE m_sGradPhaseRephFM						;
		sGRAD_PULSE m_sGradSliceRephFM						;
		sGRAD_PULSE m_sGradReadReph							;
		sGRAD_PULSE m_sGradPhaseReph						;
		sGRAD_PULSE m_sGradSliceReph						;
		sGRAD_PULSE m_sGSpoilFM								;

		SBBCALIB m_SBBCALIB;
		//. ----------------------------------------------------------
		//. Instantiate Readout objects
		//. ----------------------------------------------------------
		// every readout event must have an unique identifier
		sREADOUT               m_sADC[20]                   ;

		sREADOUT			   m_sSgADC[20]				    ;

		// define an event that undoes the receiver phase
		sFREQ_PHASE            m_sADCzNeg                  ;
		sFREQ_PHASE            m_sADCzSet   			   ;   

		sFREQ_PHASE            m_sADCsgNeg                  ; //FM_MP2RAGE
		sFREQ_PHASE            m_sADCsgSet   			   ; 

	
		//. ----------------------------------------------------------
		//. Instantiate Sync objects: Osc bit and triggering
		//. ----------------------------------------------------------
		sSYNC_OSC              m_sOscBit					;
		sSYNC_PHYSIO1_HALT     m_sTriggerBit1				;
		sSYNC_PHYSIO2_HALT     m_sTriggerBit2				;

		// The SBBList connects all Sequence Building Blocks (SBBs). It therefore knows
		//  all prepulses and can pass this information e.g. to the RSatSBBs
		SBBList                m_mySBBList;
	
		// Ajout inversion pulse
		SBBList           m_IRnsSBB;
		SeqBuildBlockIRns m_IRns;

		// SeqBuildBlockTokTokTok: Gradient knocking before measurement start (intro)
		SeqBuildBlockTokTokTok m_TokTokSBB              	;
		// SeqBuildBlockRSat: Regional saturation bands
		SeqBuildBlockRSat      m_RSatSBB[MAXRSATS]      	;
		// SeqBuildBlockCSat: Chemical shift selective saturation; can saturate water or fat
		SeqBuildBlockCSat      m_CSatFatSBB              	;
		SeqBuildBlockCSat      m_CSatWatSBB              	;
		// SeqBuildBlockMSat: MTC contrast prepulse
		SeqBuildBlockMSat      m_MSatSBB                	;
		// SeqBuildBlockTSat: Traveling Sats that follow the excited slice in a certain distance
		SeqBuildBlockTSat      m_TSatSBB                 	;
		// SeqBuildBlockSpoilGrad: Sends spoiler gradients
		SeqBuildBlockSpoilGrad m_SpoilSBB                	;

		

		//  --------------------------------------------------------------
		/// \brief <b> UI class for FM_MP2RAGE
		///
		///         This class is basically empty on the measurement system
		//  --------------------------------------------------------------
		FM_MP2RAGEUI* m_pUI;
		double      m_dDelayTI1              ;  // delay between RF pulse and start of GRE train 1
		double      m_dDelayTI2              ;  // delay between GRE train 1 and start of GRE train 2
		double      m_dDelayTR              ;  // delay between GRE train 2 and total TR


		//  ------------------------------------------------------------------
		//
		//  Name        :  FM_MP2RAGE::createUI
		//
		//  Description :
		/// \brief <b>     Instantiation of UI classes   </b>
		//
		//  Return      :  NLS status
		//
		//  ------------------------------------------------------------------
		virtual NLS_STATUS createUI (SeqLim &rSeqLim);



		//  ------------------------------------------------------------------
		//
		//  Name        :  FM_MP2RAGE::UnusedArg
		//
		//  Description :
		/// \brief         Used to avoid compiler warnings
		//
		//  Return      :  void
		//
		//  ------------------------------------------------------------------
		template< class TYPE > void UnusedArg (TYPE Argument) const { if( false ) { TYPE Dummy; Dummy = Argument; } };


	private:

		long run_kernel_counter;

		//  ------------------------------------------------------------------
		///  Copy constructor not implemented
		//  ------------------------------------------------------------------
		FM_MP2RAGE (const FM_MP2RAGE &right);



		//  ------------------------------------------------------------------
		///  Assignment operator not implemented
		//  ------------------------------------------------------------------
		FM_MP2RAGE & operator=(const FM_MP2RAGE &right);




	};


}

#endif

